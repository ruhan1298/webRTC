<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Socket.IO Call Test</title>
  <script src="https://cdn.socket.io/4.6.1/socket.io.min.js"></script>
</head>
<body>
  <h2>ğŸ“ Call Test Interface</h2>

  <label>User ID: <input type="text" id="userId" placeholder="Enter your ID" /></label>
  <button onclick="connectUser()">Connect</button>
  <br /><br />

  <label>Receiver ID: <input type="text" id="receiverId" placeholder="Enter receiver ID" /></label>
  <br /><br />

  <label>Duration (minutes): 
    <input type="number" id="callDuration" placeholder="1" min="1" max="30" value="1" />
  </label>
  <br /><br />

  <button onclick="initiateCall()">ğŸ“¤ Initiate Call</button>
  <button onclick="acceptCall()">âœ… Accept Call</button>
  <button onclick="rejectCall()">âŒ Reject Call</button>
  <button onclick="cancelCall()">ğŸ›‘ Cancel Call</button>
  <button onclick="endCall()">ğŸ“´ End Call</button>
  <br /><br />

  <p id="status" style="font-weight:bold;color:gray">Status: Not connected</p>
  <p id="callIdHolder"></p>

  <div id="logs" style="white-space: pre-wrap; background: #f5f5f5; padding: 10px; border: 1px solid #ccc; max-height: 300px; overflow-y: auto;"></div>

  <h3>ğŸ¥ Local Video (Your Camera):</h3>
  <video id="localVideo" autoplay playsinline muted style="width: 300px; border: 1px solid #999; border-radius: 8px;"></video>

  <h3>ğŸ¥ Remote Video (Other Person's Camera):</h3>
  <video id="remoteVideo" autoplay playsinline style="width: 300px; border: 1px solid #999; border-radius: 8px;"></video>

  <script>
    let socket;
    let peerConnection;
    let localStream;
    let currentCallId = null;
    let callerSocketId = null;
    let callTimer;
    let isCallInitiator = false;

    const config = {
      iceServers: [{ urls: "stun:stun.l.google.com:19302" }]
    };

    function log(msg) {
      const logs = document.getElementById("logs");
      logs.textContent += msg + "\n";
      logs.scrollTop = logs.scrollHeight;
    }

    function updateStatus(text, color = "black") {
      const statusEl = document.getElementById("status");
      statusEl.textContent = "Status: " + text;
      statusEl.style.color = color;
    }

    async function connectUser() {
      const userId = document.getElementById("userId").value.trim();
      if (!userId) return alert("Please enter a User ID.");

      socket = io("https://webrtc-1-pi3s.onrender.com/");

      socket.on("connect", () => {
        log(`âœ… Connected: ${socket.id}`);
        updateStatus("âœ… Connected", "green");
        socket.emit("register", userId);
      });

      socket.on("call:incoming", async ({ callerId, callType, callId, socketId }) => {
        currentCallId = callId;
        callerSocketId = socketId;
        isCallInitiator = false;
        log(`ğŸ“ Incoming call from ${callerId}`);
        document.getElementById("callIdHolder").textContent = `Incoming call from ${callerId}`;
      });

      socket.on("offer", async ({ offer, from }) => {
        log("ğŸ“¡ Received offer from caller");
        await startCamera();
        await createPeerConnection(from);
        await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
        const answer = await peerConnection.createAnswer();
        await peerConnection.setLocalDescription(answer);
        socket.emit("answer", { answer, to: from });
        log("ğŸ“¡ Answer sent to caller");
      });

      socket.on("answer", async ({ answer }) => {
        log("ğŸ“¡ Received answer from receiver");
        await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
        log("ğŸ“¡ Call connection established");
      });

      socket.on("ice-candidate", async ({ candidate }) => {
        if (peerConnection && peerConnection.remoteDescription) {
          try {
            await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
            log("ğŸ§Š ICE candidate added");
          } catch (e) {
            console.error("ICE candidate error:", e);
          }
        }
      });

      socket.on("call:accepted", ({ callId }) => {
        log("âœ… Call was accepted by receiver");
        startAutoEndTimer();
      });

      socket.on("call:rejected", ({ callId }) => {
        log("âŒ Call was rejected");
        resetCall();
      });

      socket.on("call:cancelled", ({ callId }) => {
        log("ğŸ›‘ Call was cancelled");
        resetCall();
      });

      socket.on("call:ended", ({ callId, duration, status }) => {
        log(`ğŸ“´ Call ended. Duration: ${duration}s, Status: ${status}`);
        document.getElementById("callIdHolder").textContent = "";
        resetCall();
      });
    }

    async function initiateCall() {
      const callerId = document.getElementById("userId").value.trim();
      const receiverId = document.getElementById("receiverId").value.trim();
      if (!callerId || !receiverId) return alert("Enter both caller and receiver IDs");

      isCallInitiator = true;
      await startCamera();
      await createPeerConnection(receiverId);

      // First emit call initiated, then create and send offer
      socket.emit("call:initiated", { callerId, receiverId, callType: "video" });
      
      const offer = await peerConnection.createOffer();
      await peerConnection.setLocalDescription(offer);
      socket.emit("offer", { offer, to: receiverId });
      
      log("ğŸ“¤ Call initiated and offer sent");
    }

    async function createPeerConnection(targetId) {
      peerConnection = new RTCPeerConnection(config);

      // Handle ICE candidates
      peerConnection.onicecandidate = (event) => {
        if (event.candidate) {
          socket.emit("ice-candidate", { candidate: event.candidate, to: targetId });
          log("ğŸ§Š ICE candidate sent");
        }
      };

      // Handle remote stream
      peerConnection.ontrack = (event) => {
        log("ğŸ¥ Remote video stream received");
        const remoteVideo = document.getElementById("remoteVideo");
        if (remoteVideo.srcObject !== event.streams[0]) {
          remoteVideo.srcObject = event.streams[0];
          log("ğŸ¥ Remote video displayed");
        }
      };

      // Handle connection state changes
      peerConnection.onconnectionstatechange = () => {
        log(`ğŸ”— Connection state: ${peerConnection.connectionState}`);
      };

      peerConnection.oniceconnectionstatechange = () => {
        log(`ğŸ§Š ICE connection state: ${peerConnection.iceConnectionState}`);
      };

      // Add local stream to peer connection
      if (localStream) {
        localStream.getTracks().forEach(track => {
          peerConnection.addTrack(track, localStream);
          log(`ğŸ“¹ Added ${track.kind} track to peer connection`);
        });
      }
    }

    async function acceptCall() {
      if (!currentCallId || !callerSocketId) return alert("No incoming call.");

      try {
        // Camera should already be started from the offer handler
        socket.emit("call:accepted", { callId: currentCallId });
        log("âœ… Call accepted - waiting for connection");
        startAutoEndTimer();
      } catch (error) {
        log("âŒ Error accepting call: " + error.message);
      }
    }

    function rejectCall() {
      if (!currentCallId) return alert("No call to reject.");
      socket.emit("call:rejected", { callId: currentCallId });
      log("âŒ Call rejected");
      resetCall();
    }

    function cancelCall() {
      if (!currentCallId) return alert("No call to cancel.");
      socket.emit("call:cancelled", { callId: currentCallId });
      log("ğŸ›‘ Call cancelled");
      resetCall();
    }

    function endCall() {
      if (!currentCallId) return alert("No call to end.");
      socket.emit("call:ended", { callId: currentCallId });
      log("ğŸ›‘ Ended the call");
      resetCall();
    }

    function resetCall() {
      currentCallId = null;
      callerSocketId = null;
      isCallInitiator = false;
      document.getElementById("callIdHolder").textContent = "";
      
      if (peerConnection) {
        peerConnection.close();
        peerConnection = null;
      }
      
      if (callTimer) {
        clearTimeout(callTimer);
        callTimer = null;
      }

      // Stop local stream
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
        localStream = null;
        document.getElementById("localVideo").srcObject = null;
        document.getElementById("remoteVideo").srcObject = null;
      }
      
      log("ğŸ”„ Call reset completed");
    }

    async function startCamera() {
      if (localStream) {
        log("ğŸ¥ Camera already active");
        return;
      }
      
      try {
        localStream = await navigator.mediaDevices.getUserMedia({ 
          video: { width: 640, height: 480 }, 
          audio: true 
        });
        document.getElementById("localVideo").srcObject = localStream;
        log("ğŸ¥ Camera & microphone access granted");
      } catch (err) {
        log("âŒ Failed to access camera/microphone: " + err.message);
        throw err;
      }
    }

    function startAutoEndTimer() {
      const durationInput = document.getElementById("callDuration").value;
      const durationInMinutes = parseInt(durationInput, 10);
      if (isNaN(durationInMinutes) || durationInMinutes <= 0) {
        log("â± Invalid duration. Defaulting to 1 minute.");
        callTimer = setTimeout(() => {
          log("âŒ› Auto-ending call (1 minute)");
          endCall();
        }, 60 * 1000);
        return;
      }
      
      callTimer = setTimeout(() => {
        log(`âŒ› Auto-ending call (${durationInMinutes} minutes)`);
        endCall();
      }, durationInMinutes * 60 * 1000);
      
      log(`â± Call will auto-end in ${durationInMinutes} minute(s)`);
    }
  </script>
</body>
</html>