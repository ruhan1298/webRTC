<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>WebRTC Video Call - Fixed Version</title>
  <script src="https://cdn.socket.io/4.6.1/socket.io.min.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 1400px;
      margin: 0 auto;
      padding: 20px;
      background: #f5f5f5;
    }
    .container {
      background: white;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    .video-container {
      display: flex;
      gap: 20px;
      margin: 20px 0;
      justify-content: center;
    }
    .video-box {
      flex: 1;
      max-width: 500px;
    }
    .video-box h3 {
      margin: 0 0 10px 0;
      padding: 10px;
      background: #f0f0f0;
      border-radius: 5px;
      text-align: center;
    }
    video {
      width: 100%;
      height: 300px;
      background: #000;
      border: 2px solid #ddd;
      border-radius: 8px;
      object-fit: cover;
    }
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      margin: 10px 0;
      padding: 15px;
      background: #f8f9fa;
      border-radius: 8px;
    }
    .controls input {
      padding: 8px 12px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
    }
    .controls button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
    }
    .btn-primary { background: #007bff; color: white; }
    .btn-success { background: #28a745; color: white; }
    .btn-danger { background: #dc3545; color: white; }
    .btn-warning { background: #ffc107; color: black; }
    .btn-secondary { background: #6c757d; color: white; }
    
    .status {
      font-weight: bold;
      padding: 12px;
      border-radius: 6px;
      margin: 10px 0;
      text-align: center;
    }
    .status.connecting { background: #cce5ff; color: #0066cc; }
    .status.connected { background: #d4edda; color: #155724; }
    .status.error { background: #f8d7da; color: #721c24; }
    .status.warning { background: #fff3cd; color: #856404; }
    
    #logs {
      background: #1a1a1a;
      color: #00ff00;
      padding: 15px;
      border-radius: 6px;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      max-height: 250px;
      overflow-y: auto;
      white-space: pre-wrap;
      margin: 20px 0;
    }
    .call-info {
      background: #e3f2fd;
      padding: 10px;
      border-left: 4px solid #2196f3;
      margin: 10px 0;
      border-radius: 4px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h2>üìû WebRTC Video Call Test - Fixed</h2>

    <div class="controls">
      <div>
        <label>Your User ID:</label>
        <input type="text" id="userId" placeholder="Enter your unique ID" />
        <button class="btn-primary" onclick="connectUser()">üîå Connect</button>
      </div>
      
      <div>
        <label>Call User ID:</label>
        <input type="text" id="receiverId" placeholder="Enter user ID to call" />
      </div>
      
      <div>
        <label>Duration:</label>
        <input type="number" id="callDuration" value="2" min="1" max="30" style="width: 60px;" /> minutes
      </div>
    </div>

    <div class="controls">
      <button class="btn-success" onclick="initiateCall()">üìû Start Call</button>
      <button class="btn-success" onclick="acceptCall()">‚úÖ Accept Call</button>
      <button class="btn-danger" onclick="rejectCall()">‚ùå Reject Call</button>
      <button class="btn-warning" onclick="cancelCall()">üõë Cancel Call</button>
      <button class="btn-secondary" onclick="endCall()">üì¥ End Call</button>
    </div>

    <div id="status" class="status">Status: Not connected</div>
    <div id="callIdHolder" class="call-info" style="display:none;"></div>

    <div class="video-container">
      <div class="video-box">
        <h3>üé• Your Video</h3>
        <video id="localVideo" autoplay playsinline muted></video>
        <div style="text-align: center; margin-top: 5px; font-size: 12px;" id="localStatus">Camera off</div>
      </div>
      <div class="video-box">
        <h3>üé• Remote Video</h3>
        <video id="remoteVideo" autoplay playsinline></video>
        <div style="text-align: center; margin-top: 5px; font-size: 12px;" id="remoteStatus">Waiting for connection</div>
      </div>
    </div>

    <div id="logs"></div>
  </div>

  <script>
    let socket;
    let peerConnection;
    let localStream;
    let currentCallId = null;
    let targetUserId = null;
    let callTimer;
    let isCallInitiator = false;

    const config = {
      iceServers: [
        { urls: "stun:stun.l.google.com:19302" },
        { urls: "stun:stun1.l.google.com:19302" },
        { urls: "stun:stun.services.mozilla.com" }
      ]
    };

    function log(msg) {
      const logs = document.getElementById("logs");
      const timestamp = new Date().toLocaleTimeString();
      logs.textContent += `[${timestamp}] ${msg}\n`;
      logs.scrollTop = logs.scrollHeight;
      console.log(`[WebRTC] ${msg}`);
    }

    function updateStatus(text, className = "") {
      const statusEl = document.getElementById("status");
      statusEl.textContent = `Status: ${text}`;
      statusEl.className = `status ${className}`;
    }

    function updateLocalStatus(text) {
      document.getElementById("localStatus").textContent = text;
    }

    function updateRemoteStatus(text) {
      document.getElementById("remoteStatus").textContent = text;
    }

    async function startCamera() {
      if (localStream) {
        // Already have stream, no need to restart camera
        log("üé• Local stream already active");
        return;
      }
      try {
        localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
        document.getElementById("localVideo").srcObject = localStream;
        updateLocalStatus("Camera on");
        log("üé• Local camera started");
      } catch (error) {
        updateLocalStatus("Camera error");
        log(`‚ùå Could not start camera: ${error.message}`);
        throw error;
      }
    }

    function stopCamera() {
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
        localStream = null;
        document.getElementById("localVideo").srcObject = null;
        updateLocalStatus("Camera off");
        log("üé• Local camera stopped");
      }
    }

    function createPeerConnection() {
      if (peerConnection) {
        peerConnection.close();
        log("üîó Closed existing peer connection");
      }

      peerConnection = new RTCPeerConnection(config);
      log("üîó Created new peer connection");

      // Add local tracks to peer connection
      if (localStream) {
        localStream.getTracks().forEach(track => {
          peerConnection.addTrack(track, localStream);
        });
        log("üéûÔ∏è Added local tracks to peer connection");
      }

      peerConnection.onicecandidate = event => {
        if (event.candidate) {
          log("üßä Sending ICE candidate");
          socket.emit("ice-candidate", { candidate: event.candidate, to: targetUserId });
        }
      };

      peerConnection.ontrack = event => {
        log("üéûÔ∏è Received remote track");
        const remoteVideo = document.getElementById("remoteVideo");
        if (!remoteVideo.srcObject) {
          remoteVideo.srcObject = new MediaStream();
        }
        remoteVideo.srcObject.addTrack(event.track);
        updateRemoteStatus("Connected");
      };

      peerConnection.onconnectionstatechange = () => {
        log(`üîó Connection state changed to: ${peerConnection.connectionState}`);
        if (peerConnection.connectionState === "connected") {
          updateStatus("Call connected", "connected");
        } else if (peerConnection.connectionState === "disconnected" || peerConnection.connectionState === "failed") {
          updateStatus("Call disconnected", "error");
          endCall();
        }
      };
    }

    // Connect user to signaling server
    function connectUser() {
      const userId = document.getElementById("userId").value.trim();
      if (!userId) {
        alert("Please enter your User ID before connecting.");
        return;
      }
      if (socket && socket.connected) {
        alert("Already connected.");
        return;
      }

      socket = io();

      socket.on("connect", () => {
        log(`üåê Connected to signaling server with socket ID: ${socket.id}`);
        updateStatus("Connected to signaling server", "connected");
        socket.emit("register", { userId });
      });

      socket.on("registered", () => {
        log(`‚úÖ Registered on server as ${userId}`);
      });

      socket.on("call-made", async ({ from, offer }) => {
        log(`üìû Incoming call from ${from}`);
        if (peerConnection) {
          log("‚ùó Already in a call, rejecting new call");
          socket.emit("call-rejected", { to: from, reason: "busy" });
          return;
        }
        targetUserId = from;
        currentCallId = generateCallId();
        isCallInitiator = false;

        await startCamera();
        createPeerConnection();

        try {
          await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
          const answer = await peerConnection.createAnswer();
          await peerConnection.setLocalDescription(answer);

          socket.emit("make-answer", { to: from, answer });
          log("‚úÖ Sent answer to caller");
          updateStatus("Call ringing...");

          // Show call ID info
          showCallId(currentCallId);

          // Start call timer
          startCallTimer();
        } catch (error) {
          log(`‚ùå Error handling call: ${error.message}`);
        }
      });

      socket.on("answer-made", async ({ from, answer }) => {
        log(`‚úÖ Received answer from ${from}`);
        try {
          await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
          updateStatus("Call connected", "connected");
          showCallId(currentCallId);
          startCallTimer();
        } catch (error) {
          log(`‚ùå Error setting remote description: ${error.message}`);
        }
      });

      socket.on("ice-candidate", async ({ candidate }) => {
        if (candidate && peerConnection) {
          try {
            await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
            log("üßä Added ICE candidate");
          } catch (error) {
            log(`‚ùå Error adding ICE candidate: ${error.message}`);
          }
        }
      });

      socket.on("call-rejected", ({ reason }) => {
        log(`‚ùå Call rejected: ${reason || "No reason provided"}`);
        alert("Call rejected by the other user.");
        updateStatus("Call rejected", "error");
        cleanupCall();
      });

      socket.on("call-canceled", () => {
        log("üõë Call canceled by the other user");
        alert("Call was canceled.");
        updateStatus("Call canceled", "warning");
        cleanupCall();
      });

      socket.on("disconnect", () => {
        log("‚ö†Ô∏è Disconnected from signaling server");
        updateStatus("Disconnected", "error");
        cleanupCall();
      });

      socket.on("error", (err) => {
        log(`‚ùå Socket error: ${err}`);
      });

      log("Connecting...");
      updateStatus("Connecting...", "connecting");
    }

    async function initiateCall() {
      const userId = document.getElementById("userId").value.trim();
      const receiverId = document.getElementById("receiverId").value.trim();

      if (!socket || !socket.connected) {
        alert("Please connect first.");
        return;
      }
      if (!receiverId) {
        alert("Please enter the User ID you want to call.");
        return;
      }
      if (peerConnection) {
        alert("Already in a call. Please end the current call first.");
        return;
      }

      targetUserId = receiverId;
      currentCallId = generateCallId();
      isCallInitiator = true;

      try {
        await startCamera();
        createPeerConnection();

        const offer = await peerConnection.createOffer();
        await peerConnection.setLocalDescription(offer);

        socket.emit("call-user", { to: receiverId, offer });
        log(`üìû Calling user ${receiverId}...`);
        updateStatus("Calling...", "connecting");
        showCallId(currentCallId);

        startCallTimer();

      } catch (error) {
        log(`‚ùå Error initiating call: ${error.message}`);
      }
    }

    function acceptCall() {
      if (!peerConnection) {
        alert("No incoming call to accept.");
        return;
      }
      log("‚úÖ Call accepted");
      updateStatus("Call accepted", "connected");
    }

    function rejectCall() {
      if (!targetUserId) {
        alert("No incoming call to reject.");
        return;
      }
      socket.emit("call-rejected", { to: targetUserId, reason: "rejected" });
      log("‚ùå Call rejected");
      updateStatus("Call rejected", "error");
      cleanupCall();
    }

    function cancelCall() {
      if (!targetUserId) {
        alert("No outgoing call to cancel.");
        return;
      }
      socket.emit("call-canceled", { to: targetUserId });
      log("üõë Call canceled");
      updateStatus("Call canceled", "warning");
      cleanupCall();
    }

    function endCall() {
      log("üì¥ Ending call");
      updateStatus("Call ended");
      cleanupCall();
    }

    function cleanupCall() {
      if (peerConnection) {
        peerConnection.close();
        peerConnection = null;
      }
      stopCamera();
      document.getElementById("remoteVideo").srcObject = null;
      updateRemoteStatus("Waiting for connection");
      currentCallId = null;
      targetUserId = null;
      isCallInitiator = false;
      hideCallId();
      stopCallTimer();
    }

    // Generate a unique call ID (simple random string)
    function generateCallId() {
      return Math.random().toString(36).substring(2, 10).toUpperCase();
    }

    function showCallId(id) {
      const holder = document.getElementById("callIdHolder");
      holder.style.display = "block";
      holder.textContent = `Call ID: ${id}`;
    }

    function hideCallId() {
      const holder = document.getElementById("callIdHolder");
      holder.style.display = "none";
      holder.textContent = "";
    }

    // Timer for call duration limit
    function startCallTimer() {
      stopCallTimer();
      const durationInput = document.getElementById("callDuration").value;
      const durationMinutes = parseInt(durationInput, 10) || 2;
      const durationMs = durationMinutes * 60 * 1000;

      callTimer = setTimeout(() => {
        alert("Call duration reached. Ending call.");
        endCall();
      }, durationMs);

      log(`‚è≤Ô∏è Call timer started for ${durationMinutes} minute(s)`);
    }

    function stopCallTimer() {
      if (callTimer) {
        clearTimeout(callTimer);
        callTimer = null;
        log("‚è≤Ô∏è Call timer stopped");
      }
    }

  </script>
</body>
</html>
