<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Socket.IO Call Test - Fixed</title>
  <script src="https://cdn.socket.io/4.6.1/socket.io.min.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
    }
    .video-container {
      display: flex;
      gap: 20px;
      margin: 20px 0;
    }
    .video-box {
      flex: 1;
    }
    video {
      width: 100%;
      max-width: 400px;
      height: 300px;
      background: #000;
      border: 1px solid #999;
      border-radius: 8px;
    }
    .controls {
      margin: 10px 0;
    }
    .controls input, .controls button {
      margin: 5px;
      padding: 8px;
    }
    #logs {
      white-space: pre-wrap;
      background: #f5f5f5;
      padding: 10px;
      border: 1px solid #ccc;
      max-height: 300px;
      overflow-y: auto;
      font-family: monospace;
      font-size: 12px;
    }
    .status {
      font-weight: bold;
      padding: 10px;
      border-radius: 4px;
      margin: 10px 0;
    }
  </style>
</head>
<body>
  <h2>ğŸ“ WebRTC Video Call Test</h2>

  <div class="controls">
    <label>User ID: <input type="text" id="userId" placeholder="Enter your ID" /></label>
    <button onclick="connectUser()">Connect</button>
    <br /><br />

    <label>Receiver ID: <input type="text" id="receiverId" placeholder="Enter receiver ID" /></label>
    <br /><br />

    <label>Duration (minutes): 
      <input type="number" id="callDuration" placeholder="1" min="1" max="30" value="1" />
    </label>
    <br /><br />

    <button onclick="initiateCall()">ğŸ“¤ Initiate Call</button>
    <button onclick="acceptCall()">âœ… Accept Call</button>
    <button onclick="rejectCall()">âŒ Reject Call</button>
    <button onclick="cancelCall()">ğŸ›‘ Cancel Call</button>
    <button onclick="endCall()">ğŸ“´ End Call</button>
  </div>

  <div id="status" class="status" style="background:#f0f0f0; color:gray">Status: Not connected</div>
  <p id="callIdHolder"></p>

  <div class="video-container">
    <div class="video-box">
      <h3>ğŸ¥ Local Video (Your Camera):</h3>
      <video id="localVideo" autoplay playsinline muted></video>
    </div>
    <div class="video-box">
      <h3>ğŸ¥ Remote Video (Other Person's Camera):</h3>
      <video id="remoteVideo" autoplay playsinline></video>
    </div>
  </div>

  <div id="logs"></div>

  <script>
    let socket;
    let peerConnection;
    let localStream;
    let currentCallId = null;
    let targetUserId = null;
    let callTimer;
    let isCallInitiator = false;
    let iceCandidateQueue = [];

    const config = {
      iceServers: [
        { urls: "stun:stun.l.google.com:19302" },
        { urls: "stun:stun1.l.google.com:19302" }
      ]
    };

    function log(msg) {
      const logs = document.getElementById("logs");
      const timestamp = new Date().toLocaleTimeString();
      logs.textContent += `[${timestamp}] ${msg}\n`;
      logs.scrollTop = logs.scrollHeight;
      console.log(msg);
    }

    function updateStatus(text, color = "black", bgColor = "#f0f0f0") {
      const statusEl = document.getElementById("status");
      statusEl.textContent = "Status: " + text;
      statusEl.style.color = color;
      statusEl.style.backgroundColor = bgColor;
    }

    async function connectUser() {
      const userId = document.getElementById("userId").value.trim();
      if (!userId) return alert("Please enter a User ID.");

      socket = io("https://webrtc-1-pi3s.onrender.com/");

      socket.on("connect", () => {
        log(`âœ… Connected with socket ID: ${socket.id}`);
        updateStatus("âœ… Connected", "green", "#e8f5e8");
        socket.emit("register", userId);
      });

      socket.on("call:incoming", async ({ callerId, callType, callId, socketId }) => {
        currentCallId = callId;
        targetUserId = callerId;
        isCallInitiator = false;
        log(`ğŸ“ Incoming ${callType} call from ${callerId} (${socketId})`);
        updateStatus(`ğŸ“ Incoming call from ${callerId}`, "blue", "#e8f0ff");
        document.getElementById("callIdHolder").textContent = `Incoming call from ${callerId}`;
      });

      socket.on("offer", async ({ offer, from }) => {
        log(`ğŸ“¡ Received offer from ${from}`);
        try {
          targetUserId = from;
          await handleIncomingOffer(offer, from);
        } catch (error) {
          log(`âŒ Error handling offer: ${error.message}`);
        }
      });

      socket.on("answer", async ({ answer, from }) => {
        log(`ğŸ“¡ Received answer from ${from}`);
        try {
          await handleIncomingAnswer(answer);
        } catch (error) {
          log(`âŒ Error handling answer: ${error.message}`);
        }
      });

      socket.on("ice-candidate", async ({ candidate, from }) => {
        log(`ğŸ§Š Received ICE candidate from ${from}`);
        try {
          await handleIceCandidate(candidate);
        } catch (error) {
          log(`âŒ ICE candidate error: ${error.message}`);
        }
      });

      socket.on("call:accepted", ({ callId }) => {
        log("âœ… Call was accepted by receiver");
        updateStatus("âœ… Call Active", "green", "#e8f5e8");
        startAutoEndTimer();
      });

      socket.on("call:rejected", ({ callId }) => {
        log("âŒ Call was rejected");
        updateStatus("âŒ Call Rejected", "red", "#ffe8e8");
        resetCall();
      });

      socket.on("call:cancelled", ({ callId }) => {
        log("ğŸ›‘ Call was cancelled");
        updateStatus("ğŸ›‘ Call Cancelled", "orange", "#fff3e8");
        resetCall();
      });

      socket.on("call:ended", ({ callId, duration, status }) => {
        log(`ğŸ“´ Call ended. Duration: ${duration}s, Status: ${status}`);
        updateStatus("ğŸ“´ Call Ended", "gray", "#f0f0f0");
        document.getElementById("callIdHolder").textContent = "";
        resetCall();
      });

      socket.on("disconnect", () => {
        log("âŒ Disconnected from server");
        updateStatus("âŒ Disconnected", "red", "#ffe8e8");
      });
    }

    async function initiateCall() {
      const callerId = document.getElementById("userId").value.trim();
      const receiverId = document.getElementById("receiverId").value.trim();
      if (!callerId || !receiverId) return alert("Enter both caller and receiver IDs");

      try {
        isCallInitiator = true;
        targetUserId = receiverId;
        
        log(`ğŸ“¤ Initiating call to ${receiverId}...`);
        updateStatus("ğŸ“¤ Initiating call...", "blue", "#e8f0ff");

        // Start camera first
        await startCamera();
        
        // Create peer connection
        await createPeerConnection();
        
        // Create and send offer
        const offer = await peerConnection.createOffer({
          offerToReceiveAudio: true,
          offerToReceiveVideo: true
        });
        await peerConnection.setLocalDescription(offer);
        
        // Emit call initiated and offer
        socket.emit("call:initiated", { callerId, receiverId, callType: "video" });
        socket.emit("offer", { offer, to: receiverId });

        log("ğŸ“¤ Call initiated and offer sent");
      } catch (error) {
        log(`âŒ Error initiating call: ${error.message}`);
        updateStatus("âŒ Call Failed", "red", "#ffe8e8");
        resetCall();
      }
    }

    async function handleIncomingOffer(offer, from) {
      try {
        // Start camera
        await startCamera();
        
        // Create peer connection
        await createPeerConnection();
        
        // Set remote description
        await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
        
        // Process queued ICE candidates
        while (iceCandidateQueue.length > 0) {
          const candidate = iceCandidateQueue.shift();
          await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
        }
        
        // Create and send answer
        const answer = await peerConnection.createAnswer();
        await peerConnection.setLocalDescription(answer);
        socket.emit("answer", { answer, to: from });
        
        log("ğŸ“¡ Answer sent to caller");
      } catch (error) {
        log(`âŒ Error in handleIncomingOffer: ${error.message}`);
        throw error;
      }
    }

    async function handleIncomingAnswer(answer) {
      try {
        await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
        
        // Process queued ICE candidates
        while (iceCandidateQueue.length > 0) {
          const candidate = iceCandidateQueue.shift();
          await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
        }
        
        log("ğŸ“¡ Answer processed - connection should be established");
        updateStatus("ğŸ“¡ Connecting...", "blue", "#e8f0ff");
      } catch (error) {
        log(`âŒ Error processing answer: ${error.message}`);
        throw error;
      }
    }

    async function handleIceCandidate(candidate) {
      try {
        if (peerConnection && peerConnection.remoteDescription) {
          await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
          log("ğŸ§Š ICE candidate added successfully");
        } else {
          iceCandidateQueue.push(candidate);
          log("ğŸ§Š ICE candidate queued (remote description not ready)");
        }
      } catch (error) {
        log(`âŒ ICE candidate error: ${error.message}`);
        throw error;
      }
    }

    async function createPeerConnection() {
      if (peerConnection) {
        peerConnection.close();
      }

      peerConnection = new RTCPeerConnection(config);
      log("ğŸ”— Created new peer connection");

      // Set up remote video stream
      const remoteVideo = document.getElementById("remoteVideo");
      
      peerConnection.ontrack = (event) => {
        log(`ğŸ¥ Received remote track: ${event.track.kind}`);
        if (event.streams && event.streams[0]) {
          remoteVideo.srcObject = event.streams[0];
          log("ğŸ¥ Remote video stream connected");
        }
      };

      peerConnection.onicecandidate = (event) => {
        if (event.candidate && targetUserId) {
          socket.emit("ice-candidate", { candidate: event.candidate, to: targetUserId });
          log("ğŸ§Š ICE candidate sent");
        }
      };

      peerConnection.onconnectionstatechange = () => {
        const state = peerConnection.connectionState;
        log(`ğŸ”— Connection state: ${state}`);
        
        switch (state) {
          case 'connected':
            updateStatus("âœ… Connected", "green", "#e8f5e8");
            break;
          case 'disconnected':
            updateStatus("âš ï¸ Disconnected", "orange", "#fff3e8");
            break;
          case 'failed':
            updateStatus("âŒ Connection Failed", "red", "#ffe8e8");
            resetCall();
            break;
        }
      };

      peerConnection.oniceconnectionstatechange = () => {
        log(`ğŸ§Š ICE connection state: ${peerConnection.iceConnectionState}`);
      };

      // Add local stream tracks
      if (localStream) {
        localStream.getTracks().forEach(track => {
          peerConnection.addTrack(track, localStream);
          log(`ğŸ“¹ Added ${track.kind} track to peer connection`);
        });
      } else {
        log("âš ï¸ No local stream available to add to peer connection");
      }
    }

    async function acceptCall() {
      if (!currentCallId) return alert("No incoming call to accept.");
      try {
        log("âœ… Accepting call...");
        socket.emit("call:accepted", { callId: currentCallId });
        updateStatus("âœ… Call Accepted", "green", "#e8f5e8");
        startAutoEndTimer();
      } catch (error) {
        log(`âŒ Error accepting call: ${error.message}`);
      }
    }

    function rejectCall() {
      if (!currentCallId) return alert("No call to reject.");
      socket.emit("call:rejected", { callId: currentCallId });
      log("âŒ Call rejected");
      resetCall();
    }

    function cancelCall() {
      if (!currentCallId) return alert("No call to cancel.");
      socket.emit("call:cancelled", { callId: currentCallId });
      log("ğŸ›‘ Call cancelled");
      resetCall();
    }

    function endCall() {
      if (!currentCallId) return alert("No call to end.");
      socket.emit("call:ended", { callId: currentCallId });
      log("ğŸ›‘ Ended the call");
      resetCall();
    }

    function resetCall() {
      currentCallId = null;
      targetUserId = null;
      isCallInitiator = false;
      iceCandidateQueue = [];
      document.getElementById("callIdHolder").textContent = "";

      if (peerConnection) {
        peerConnection.close();
        peerConnection = null;
        log("ğŸ”— Peer connection closed");
      }

      if (callTimer) {
        clearTimeout(callTimer);
        callTimer = null;
      }

      if (localStream) {
        localStream.getTracks().forEach(track => {
          track.stop();
          log(`ğŸ›‘ Stopped ${track.kind} track`);
        });
        localStream = null;
      }

      // Clear video elements
      document.getElementById("localVideo").srcObject = null;
      document.getElementById("remoteVideo").srcObject = null;

      updateStatus("ğŸ”„ Ready for new call", "gray", "#f0f0f0");
      log("ğŸ”„ Call reset completed");
    }

    async function startCamera() {
      if (localStream) {
        log("ğŸ¥ Camera already active");
        return;
      }

      try {
        localStream = await navigator.mediaDevices.getUserMedia({
          video: { 
            width: { ideal: 640 }, 
            height: { ideal: 480 },
            facingMode: 'user'
          },
          audio: {
            echoCancellation: true,
            noiseSuppression: true
          }
        });
        
        document.getElementById("localVideo").srcObject = localStream;
        log(`ğŸ¥ Camera & microphone access granted - ${localStream.getTracks().length} tracks`);
        
        // Log track details
        localStream.getTracks().forEach(track => {
          log(`ğŸ“¹ Local track: ${track.kind} - ${track.label}`);
        });
        
      } catch (err) {
        log(`âŒ Failed to access camera/microphone: ${err.message}`);
        throw err;
      }
    }

    function startAutoEndTimer() {
      const durationInput = document.getElementById("callDuration").value;
      const minutes = parseInt(durationInput, 10);
      const ms = (isNaN(minutes) ? 1 : minutes) * 60 * 1000;

      callTimer = setTimeout(() => {
        log("â±ï¸ Auto-ending call after duration limit");
        endCall();
      }, ms);
      
      log(`â±ï¸ Auto-end timer set for ${minutes} minute(s)`);
    }
  </script>
</body>
</html>