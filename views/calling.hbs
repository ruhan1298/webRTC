<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Socket.IO Call Test</title>
  <script src="https://cdn.socket.io/4.6.1/socket.io.min.js"></script>
</head>
<body>
  <h2>üìû Call Test Interface</h2>

  <label>User ID: <input type="text" id="userId" placeholder="Enter your ID" /></label>
  <button onclick="connectUser()">Connect</button>
  <br /><br />

  <label>Receiver ID: <input type="text" id="receiverId" placeholder="Enter receiver ID" /></label>
  <br /><br />

  <label>Duration (minutes): 
    <input type="number" id="callDuration" placeholder="1" min="1" max="30" value="1" />
  </label>
  <br /><br />

  <button onclick="initiateCall()">üì§ Initiate Call</button>
  <button onclick="acceptCall()">‚úÖ Accept Call</button>
  <button onclick="rejectCall()">‚ùå Reject Call</button>
  <button onclick="cancelCall()">üõë Cancel Call</button>
  <button onclick="endCall()">üì¥ End Call</button>
  <br /><br />

  <p id="status" style="font-weight:bold;color:gray">Status: Not connected</p>
  <p id="callIdHolder"></p>

  <div id="logs" style="white-space: pre-wrap; background: #f5f5f5; padding: 10px; border: 1px solid #ccc; max-height: 300px; overflow-y: auto;"></div>

  <h3>üé• Local Video Preview:</h3>
  <video id="localVideo" autoplay playsinline muted style="width: 300px; border: 1px solid #999; border-radius: 8px;"></video>

  <h3>üé• Remote Video Preview:</h3>
  <video id="remoteVideo" autoplay playsinline style="width: 300px; border: 1px solid #999; border-radius: 8px;"></video>

  <script>
    let socket;
    let peerConnection;
    let localStream;
    let currentCallId = null;
    let callerSocketId = null;
    let callTimer;

    const config = {
      iceServers: [{ urls: "stun:stun.l.google.com:19302" }]
    };

    function log(msg) {
      const logs = document.getElementById("logs");
      logs.textContent += msg + "\n";
      logs.scrollTop = logs.scrollHeight;
    }

    function updateStatus(text, color = "black") {
      const statusEl = document.getElementById("status");
      statusEl.textContent = "Status: " + text;
      statusEl.style.color = color;
    }

    async function connectUser() {
      const userId = document.getElementById("userId").value.trim();
      if (!userId) return alert("Please enter a User ID.");

      socket = io("https://webrtc-1-pi3s.onrender.com/");

      socket.on("connect", () => {
        log(`‚úÖ Connected: ${socket.id}`);
        updateStatus("‚úÖ Connected", "green");
        socket.emit("register", userId);
      });

      socket.on("call:incoming", async ({ callerId, callType, callId, socketId }) => {
        currentCallId = callId;
        callerSocketId = socketId; // Save caller's socket id
        log(`üìû Incoming call from ${callerId}`);
        document.getElementById("callIdHolder").textContent = `Incoming call from ${callerId}`;
      });

      socket.on("offer", async ({ offer, from }) => {
        await startCamera();
        createPeerConnection(from);
        await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
        const answer = await peerConnection.createAnswer();
        await peerConnection.setLocalDescription(answer);
        socket.emit("answer", { answer, to: from });
        log("üì° Answer sent");
      });

      socket.on("answer", async ({ answer }) => {
        await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
        log("üì° Answer received");
      });

      socket.on("ice-candidate", async ({ candidate }) => {
        if (peerConnection) {
          try {
            await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
          } catch (e) {
            console.error("ICE error", e);
          }
        }
      });

      socket.on("call:ended", ({ callId, duration, status }) => {
        log(`üì¥ Call ended. Duration: ${duration}s, Status: ${status}`);
        document.getElementById("callIdHolder").textContent = "";
        resetCall();
      });
    }

    async function initiateCall() {
      const callerId = document.getElementById("userId").value.trim();
      const receiverId = document.getElementById("receiverId").value.trim();
      if (!callerId || !receiverId) return alert("Enter both caller and receiver IDs");

      await startCamera();
      createPeerConnection(receiverId);

      const offer = await peerConnection.createOffer();
      await peerConnection.setLocalDescription(offer);
      socket.emit("offer", { offer, to: receiverId });
      socket.emit("call:initiated", { callerId, receiverId, callType: "video" });
      log("üì§ Offer sent & call initiated");
    }

    function createPeerConnection(targetId) {
      peerConnection = new RTCPeerConnection(config);

      peerConnection.onicecandidate = (event) => {
        if (event.candidate) {
          socket.emit("ice-candidate", { candidate: event.candidate, to: targetId });
        }
      };

      peerConnection.ontrack = (event) => {
        document.getElementById("remoteVideo").srcObject = event.streams[0];
      };

      localStream.getTracks().forEach(track => {
        peerConnection.addTrack(track, localStream);
      });
    }

    async function acceptCall() {
      if (!currentCallId || !callerSocketId) return alert("No incoming call.");

      await startCamera();
      createPeerConnection(callerSocketId); // Now create peer connection
      socket.emit("call:accepted", { callId: currentCallId });
      log("‚úÖ Call accepted");
      startAutoEndTimer();
    }

    function rejectCall() {
      if (!currentCallId) return alert("No call to reject.");
      socket.emit("call:rejected", { callId: currentCallId });
      log("‚ùå Call rejected");
      resetCall();
    }

    function cancelCall() {
      if (!currentCallId) return alert("No call to cancel.");
      socket.emit("call:cancelled", { callId: currentCallId });
      log("üõë Call cancelled");
      resetCall();
    }

    function endCall() {
      if (!currentCallId) return alert("No call to end.");
      socket.emit("call:ended", { callId: currentCallId });
      log("üõë Ended the call");
      resetCall();
    }

    function resetCall() {
      currentCallId = null;
      callerSocketId = null;
      document.getElementById("callIdHolder").textContent = "";
      if (peerConnection) peerConnection.close();
      peerConnection = null;
      if (callTimer) clearTimeout(callTimer);
    }

    async function startCamera() {
      try {
        localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
        document.getElementById("localVideo").srcObject = localStream;
        log("üé• Camera & mic access granted");
      } catch (err) {
        log("‚ùå Failed to access camera/mic");
        throw err;
      }
    }

    function startAutoEndTimer() {
      const durationInput = document.getElementById("callDuration").value;
      const durationInMinutes = parseInt(durationInput, 10);
      if (isNaN(durationInMinutes) || durationInMinutes <= 0) {
        alert("‚è± Invalid duration. Defaulting to 1 minute.");
        return;
      }
      callTimer = setTimeout(() => {
        log("‚åõ Auto-ending call");
        endCall();
      }, durationInMinutes * 60 * 1000);
    }
  </script>
</body>
</html>
