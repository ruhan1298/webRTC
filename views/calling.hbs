<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>WebRTC Video Call - Fixed Version</title>
  <script src="https://cdn.socket.io/4.6.1/socket.io.min.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 1400px;
      margin: 0 auto;
      padding: 20px;
      background: #f5f5f5;
    }
    .container {
      background: white;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    .video-container {
      display: flex;
      gap: 20px;
      margin: 20px 0;
      justify-content: center;
    }
    .video-box {
      flex: 1;
      max-width: 500px;
    }
    .video-box h3 {
      margin: 0 0 10px 0;
      padding: 10px;
      background: #f0f0f0;
      border-radius: 5px;
      text-align: center;
    }
    video {
      width: 100%;
      height: 300px;
      background: #000;
      border: 2px solid #ddd;
      border-radius: 8px;
      object-fit: cover;
    }
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      margin: 10px 0;
      padding: 15px;
      background: #f8f9fa;
      border-radius: 8px;
    }
    .controls input {
      padding: 8px 12px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
    }
    .controls button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
    }
    .btn-primary { background: #007bff; color: white; }
    .btn-success { background: #28a745; color: white; }
    .btn-danger { background: #dc3545; color: white; }
    .btn-warning { background: #ffc107; color: black; }
    .btn-secondary { background: #6c757d; color: white; }
    
    .status {
      font-weight: bold;
      padding: 12px;
      border-radius: 6px;
      margin: 10px 0;
      text-align: center;
    }
    .status.connecting { background: #cce5ff; color: #0066cc; }
    .status.connected { background: #d4edda; color: #155724; }
    .status.error { background: #f8d7da; color: #721c24; }
    .status.warning { background: #fff3cd; color: #856404; }
    
    #logs {
      background: #1a1a1a;
      color: #00ff00;
      padding: 15px;
      border-radius: 6px;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      max-height: 250px;
      overflow-y: auto;
      white-space: pre-wrap;
      margin: 20px 0;
    }
    .call-info {
      background: #e3f2fd;
      padding: 10px;
      border-left: 4px solid #2196f3;
      margin: 10px 0;
      border-radius: 4px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h2>üìû WebRTC Video Call Test - Fixed</h2>

    <div class="controls">
      <div>
        <label>Your User ID:</label>
        <input type="text" id="userId" placeholder="Enter your unique ID" />
        <button class="btn-primary" onclick="connectUser()">üîå Connect</button>
      </div>
      
      <div>
        <label>Call User ID:</label>
        <input type="text" id="receiverId" placeholder="Enter user ID to call" />
      </div>
      
      <div>
        <label>Duration:</label>
        <input type="number" id="callDuration" value="2" min="1" max="30" style="width: 60px;" /> minutes
      </div>
    </div>

    <div class="controls">
      <button class="btn-success" onclick="initiateCall()">üìû Start Call</button>
      <button class="btn-success" onclick="acceptCall()">‚úÖ Accept Call</button>
      <button class="btn-danger" onclick="rejectCall()">‚ùå Reject Call</button>
      <button class="btn-warning" onclick="cancelCall()">üõë Cancel Call</button>
      <button class="btn-secondary" onclick="endCall()">üì¥ End Call</button>
    </div>

    <div id="status" class="status">Status: Not connected</div>
    <div id="callIdHolder" class="call-info" style="display:none;"></div>

    <div class="video-container">
      <div class="video-box">
        <h3>üé• Your Video</h3>
        <video id="localVideo" autoplay playsinline muted></video>
        <div style="text-align: center; margin-top: 5px; font-size: 12px;" id="localStatus">Camera off</div>
      </div>
      <div class="video-box">
        <h3>üé• Remote Video</h3>
        <video id="remoteVideo" autoplay playsinline></video>
        <div style="text-align: center; margin-top: 5px; font-size: 12px;" id="remoteStatus">Waiting for connection</div>
      </div>
    </div>

    <div id="logs"></div>
  </div>

  <script>
    let socket;
    let peerConnection;
    let localStream;
    let currentCallId = null;
    let targetUserId = null;
    let callTimer;
    let isCallInitiator = false;

    const config = {
      iceServers: [
        { urls: "stun:stun.l.google.com:19302" },
        { urls: "stun:stun1.l.google.com:19302" },
        { urls: "stun:stun.services.mozilla.com" }
      ]
    };

    function log(msg) {
      const logs = document.getElementById("logs");
      const timestamp = new Date().toLocaleTimeString();
      logs.textContent += `[${timestamp}] ${msg}\n`;
      logs.scrollTop = logs.scrollHeight;
      console.log(`[WebRTC] ${msg}`);
    }

    function updateStatus(text, className = "") {
      const statusEl = document.getElementById("status");
      statusEl.textContent = text;
      statusEl.className = `status ${className}`;
    }

    function updateLocalStatus(text) {
      document.getElementById("localStatus").textContent = text;
    }

    function updateRemoteStatus(text) {
      document.getElementById("remoteStatus").textContent = text;
    }

    async function connectUser() {
      const userId = document.getElementById("userId").value.trim();
      if (!userId) return alert("Please enter your User ID first!");

      if (socket) {
        socket.disconnect();
      }

      socket = io("https://webrtc-1-pi3s.onrender.com/");

      socket.on("connect", () => {
        log(`‚úÖ Connected to server with socket ID: ${socket.id}`);
        updateStatus("‚úÖ Connected to server", "connected");
        socket.emit("register", userId);
        log(`üìù Registered as user: ${userId}`);
      });

      socket.on("call:incoming", async ({ callerId, callType, callId, socketId }) => {
        currentCallId = callId;
        targetUserId = callerId;
        isCallInitiator = false;
        
        log(`üìû Incoming ${callType} call from ${callerId}`);
        updateStatus(`üìû Incoming call from ${callerId}`, "warning");
        
        const callInfo = document.getElementById("callIdHolder");
        callInfo.textContent = `üìû Incoming call from: ${callerId}`;
        callInfo.style.display = "block";
      });

      socket.on("offer", async ({ offer, from }) => {
        log(`üì° Received offer from: ${from}`);
        await handleOffer(offer, from);
      });

      socket.on("answer", async ({ answer, from }) => {
        log(`üì° Received answer from: ${from}`);
        await handleAnswer(answer);
      });

      socket.on("ice-candidate", async ({ candidate, from }) => {
        log(`üßä Received ICE candidate from: ${from}`);
        await handleIceCandidate(candidate);
      });

      socket.on("call:accepted", ({ callId }) => {
        log("‚úÖ Call accepted by remote user");
        updateStatus("‚úÖ Call Active", "connected");
        startAutoEndTimer();
      });

      socket.on("call:rejected", ({ callId }) => {
        log("‚ùå Call rejected by remote user");
        updateStatus("‚ùå Call Rejected", "error");
        resetCall();
      });

      socket.on("call:cancelled", ({ callId }) => {
        log("üõë Call cancelled");
        updateStatus("üõë Call Cancelled", "warning");
        resetCall();
      });

      socket.on("call:ended", ({ callId, duration, status }) => {
        log(`üì¥ Call ended - Duration: ${duration}s`);
        updateStatus("üì¥ Call Ended", "");
        resetCall();
      });

      socket.on("disconnect", () => {
        log("‚ùå Disconnected from server");
        updateStatus("‚ùå Disconnected", "error");
      });
    }

    async function initiateCall() {
      const callerId = document.getElementById("userId").value.trim();
      const receiverId = document.getElementById("receiverId").value.trim();
      
      if (!callerId || !receiverId) {
        return alert("Please enter both User IDs!");
      }
      
      if (!socket || !socket.connected) {
        return alert("Please connect to server first!");
      }

      try {
        log(`üìû Starting call to ${receiverId}...`);
        updateStatus("üìû Initiating call...", "connecting");
        
        isCallInitiator = true;
        targetUserId = receiverId;

        // Start local camera FIRST
        await startCamera();
        log("üìπ Local camera started successfully");

        // Create peer connection
        createPeerConnection();
        log("üîó Peer connection created");

        // Create offer
        const offer = await peerConnection.createOffer({
          offerToReceiveAudio: true,
          offerToReceiveVideo: true
        });
        
        await peerConnection.setLocalDescription(offer);
        log("üì° Local description set with offer");

        // Send call initiation and offer
        socket.emit("call:initiated", { callerId, receiverId, callType: "video" });
        socket.emit("offer", { offer, to: receiverId });
        
        log("üì§ Offer sent to remote user");
        updateStatus("üì§ Calling...", "connecting");

      } catch (error) {
        log(`‚ùå Error initiating call: ${error.message}`);
        updateStatus("‚ùå Call failed", "error");
        resetCall();
      }
    }

    async function handleOffer(offer, from) {
      try {
        targetUserId = from;
        
        // Start camera for receiver
        await startCamera();
        log("üìπ Camera started for incoming call");

        // Create peer connection
        createPeerConnection();
        log("üîó Peer connection created for incoming call");

        // Set remote description
        await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
        log("üì° Remote description set from offer");

        // Create answer
        const answer = await peerConnection.createAnswer({
          offerToReceiveAudio: true,
          offerToReceiveVideo: true
        });
        
        await peerConnection.setLocalDescription(answer);
        log("üì° Local description set with answer");

        // Send answer
        socket.emit("answer", { answer, to: from });
        log("üì§ Answer sent to caller");

      } catch (error) {
        log(`‚ùå Error handling offer: ${error.message}`);
        updateStatus("‚ùå Call setup failed", "error");
      }
    }

    async function handleAnswer(answer) {
      try {
        await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
        log("üì° Remote description set from answer");
        updateStatus("üì° Connecting...", "connecting");
      } catch (error) {
        log(`‚ùå Error handling answer: ${error.message}`);
      }
    }

    async function handleIceCandidate(candidate) {
      try {
        if (peerConnection && peerConnection.remoteDescription) {
          await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
          log("üßä ICE candidate added successfully");
        } else {
          log("‚ö†Ô∏è ICE candidate received but remote description not ready");
        }
      } catch (error) {
        log(`‚ùå ICE candidate error: ${error.message}`);
      }
    }

    function createPeerConnection() {
      if (peerConnection) {
        peerConnection.close();
        log("üîó Closed existing peer connection");
      }

      peerConnection = new RTCPeerConnection(config);
      log("üîó New peer connection created");

      // Add local stream tracks IMMEDIATELY
      if (localStream) {
        localStream.getTracks().forEach(track => {
          const sender = peerConnection.addTrack(track, localStream);
          log(`üìπ Added local ${track.kind} track to peer connection`);
        });
      }

      // Handle incoming remote stream
      peerConnection.ontrack = (event) => {
        log(`üé• Received remote ${event.track.kind} track`);
        
        const remoteVideo = document.getElementById("remoteVideo");
        
        if (event.streams && event.streams[0]) {
          remoteVideo.srcObject = event.streams[0];
          updateRemoteStatus("Remote video connected");
          log("üé• Remote stream connected to video element");
          
          // Force play
          remoteVideo.play().catch(e => log(`Video play error: ${e.message}`));
        }
      };

      // ICE candidate handling
      peerConnection.onicecandidate = (event) => {
        if (event.candidate && targetUserId) {
          socket.emit("ice-candidate", { candidate: event.candidate, to: targetUserId });
          log(`üßä Sent ICE candidate: ${event.candidate.type}`);
        }
      };

      // Connection state monitoring
      peerConnection.onconnectionstatechange = () => {
        const state = peerConnection.connectionState;
        log(`üîó Connection state: ${state}`);
        
        switch (state) {
          case 'connecting':
            updateStatus("üîó Connecting...", "connecting");
            break;
          case 'connected':
            updateStatus("‚úÖ Video call active", "connected");
            updateRemoteStatus("Connected");
            break;
          case 'disconnected':
            updateStatus("‚ö†Ô∏è Connection lost", "warning");
            updateRemoteStatus("Disconnected");
            break;
          case 'failed':
            updateStatus("‚ùå Connection failed", "error");
            updateRemoteStatus("Connection failed");
            setTimeout(resetCall, 3000);
            break;
        }
      };

      peerConnection.oniceconnectionstatechange = () => {
        log(`üßä ICE state: ${peerConnection.iceConnectionState}`);
      };
    }

    async function startCamera() {
      if (localStream) {
        log("üé• Camera already active");
        return;
      }

      try {
        log("üé• Requesting camera access...");
        updateLocalStatus("Requesting camera...");

        localStream = await navigator.mediaDevices.getUserMedia({
          video: {
            width: { ideal: 640, max: 1280 },
            height: { ideal: 480, max: 720 },
            facingMode: 'user'
          },
          audio: {
            echoCancellation: true,
            noiseSuppression: true
          }
        });

        const localVideo = document.getElementById("localVideo");
        localVideo.srcObject = localStream;
        updateLocalStatus(`Camera active (${localStream.getTracks().length} tracks)`);
        
        // Force play local video
        localVideo.play().catch(e => log(`Local video play error: ${e.message}`));

        log(`üé• Camera started - ${localStream.getTracks().length} tracks available`);
        
        // Log track details
        localStream.getTracks().forEach(track => {
          log(`üìπ Local track: ${track.kind} - ${track.readyState}`);
        });

      } catch (error) {
        log(`‚ùå Camera error: ${error.message}`);
        updateLocalStatus("Camera failed");
        alert(`Camera access failed: ${error.message}`);
        throw error;
      }
    }

    async function acceptCall() {
      if (!currentCallId) {
        return alert("No incoming call to accept!");
      }

      try {
        log("‚úÖ Accepting call...");
        socket.emit("call:accepted", { callId: currentCallId });
        updateStatus("‚úÖ Call accepted", "connected");
        startAutoEndTimer();
        
        document.getElementById("callIdHolder").style.display = "none";
      } catch (error) {
        log(`‚ùå Error accepting call: ${error.message}`);
      }
    }

    function rejectCall() {
      if (!currentCallId) return alert("No call to reject!");
      socket.emit("call:rejected", { callId: currentCallId });
      log("‚ùå Call rejected");
      resetCall();
    }

    function cancelCall() {
      if (!currentCallId) return alert("No call to cancel!");
      socket.emit("call:cancelled", { callId: currentCallId });
      log("üõë Call cancelled");
      resetCall();
    }

    function endCall() {
      if (!currentCallId) return alert("No active call to end!");
      socket.emit("call:ended", { callId: currentCallId });
      log("üì¥ Call ended by user");
      resetCall();
    }

    function resetCall() {
      currentCallId = null;
      targetUserId = null;
      isCallInitiator = false;
      
      document.getElementById("callIdHolder").style.display = "none";

      if (peerConnection) {
        peerConnection.close();
        peerConnection = null;
        log("üîó Peer connection closed");
      }

      if (callTimer) {
        clearTimeout(callTimer);
        callTimer = null;
      }

      if (localStream) {
        localStream.getTracks().forEach(track => {
          track.stop();
          log(`üõë Stopped ${track.kind} track`);
        });
        localStream = null;
      }

      // Clear video displays
      document.getElementById("localVideo").srcObject = null;
      document.getElementById("remoteVideo").srcObject = null;
      
      updateLocalStatus("Camera off");
      updateRemoteStatus("Waiting for connection");
      updateStatus("Ready for new call", "");
      
      log("üîÑ Call reset completed");
    }

    function startAutoEndTimer() {
      const minutes = parseInt(document.getElementById("callDuration").value) || 2;
      const ms = minutes * 60 * 1000;

      callTimer = setTimeout(() => {
        log(`‚è∞ Auto-ending call after ${minutes} minutes`);
        endCall();
      }, ms);

      log(`‚è∞ Auto-end timer set for ${minutes} minutes`);
    }

    // Initialize
    log("üöÄ WebRTC Video Call Interface Ready");
    updateStatus("Ready - Enter User ID and connect", "");
  </script>
</body>
</html>