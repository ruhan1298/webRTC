<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Socket.IO Call Test</title>
  <script src="https://cdn.socket.io/4.6.1/socket.io.min.js"></script>
</head>
<body>
  <h2>📞 Call Test Interface</h2>

  <label>User ID: <input type="text" id="userId" placeholder="Enter your ID" /></label>
  <button onclick="connectUser()">Connect</button>
  <br /><br />

  <label>Receiver ID: <input type="text" id="receiverId" placeholder="Enter receiver ID" /></label>
  <br /><br />

  <label>Duration (minutes): 
    <input type="number" id="callDuration" placeholder="1" min="1" max="30" value="1" />
  </label>
  <br /><br />

  <button onclick="initiateCall()">📤 Initiate Call</button>
  <button onclick="acceptCall()">✅ Accept Call</button>
  <button onclick="rejectCall()">❌ Reject Call</button>
  <button onclick="cancelCall()">🛑 Cancel Call</button>
  <button onclick="endCall()">📴 End Call</button>
  <br /><br />

  <p id="status" style="font-weight:bold;color:gray">Status: Not connected</p>
  <p id="callIdHolder"></p>

  <div id="logs" style="white-space: pre-wrap; background: #f5f5f5; padding: 10px; border: 1px solid #ccc; max-height: 300px; overflow-y: auto;"></div>

  <h3>🎥 Local Video (Your Camera):</h3>
  <video id="localVideo" autoplay playsinline muted style="width: 300px; border: 1px solid #999; border-radius: 8px;"></video>

  <h3>🎥 Remote Video (Other Person's Camera):</h3>
  <video id="remoteVideo" autoplay playsinline style="width: 300px; border: 1px solid #999; border-radius: 8px;"></video>

  <script>
    let socket;
    let peerConnection;
    let localStream;
    let remoteStream = new MediaStream();
    let currentCallId = null;
    let callerSocketId = null;
    let callTimer;
    let isCallInitiator = false;

    const config = {
      iceServers: [{ urls: "stun:stun.l.google.com:19302" }]
    };

    function log(msg) {
      const logs = document.getElementById("logs");
      logs.textContent += msg + "\n";
      logs.scrollTop = logs.scrollHeight;
    }

    function updateStatus(text, color = "black") {
      const statusEl = document.getElementById("status");
      statusEl.textContent = "Status: " + text;
      statusEl.style.color = color;
    }

    async function connectUser() {
      const userId = document.getElementById("userId").value.trim();
      if (!userId) return alert("Please enter a User ID.");

      socket = io("https://webrtc-1-pi3s.onrender.com/");

      socket.on("connect", () => {
        log(`✅ Connected: ${socket.id}`);
        updateStatus("✅ Connected", "green");
        socket.emit("register", userId);
      });

      socket.on("call:incoming", async ({ callerId, callType, callId, socketId }) => {
        currentCallId = callId;
        callerSocketId = socketId;
        isCallInitiator = false;
        log(`📞 Incoming call from ${callerId}`);
        document.getElementById("callIdHolder").textContent = `Incoming call from ${callerId}`;
      });

      socket.on("offer", async ({ offer, from }) => {
        log("📡 Received offer from caller");
        try {
          await startCamera();
          callerSocketId = from;
          await createPeerConnection(from);
          await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
          const answer = await peerConnection.createAnswer();
          await peerConnection.setLocalDescription(answer);
          socket.emit("answer", { answer, to: from });
          log("📡 Answer sent to caller");
        } catch (error) {
          log("❌ Error handling offer: " + error.message);
        }
      });

      socket.on("answer", async ({ answer }) => {
        log("📡 Received answer from receiver");
        await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
        log("📡 Call connection established");
      });

      socket.on("ice-candidate", async ({ candidate }) => {
        if (peerConnection && peerConnection.remoteDescription) {
          try {
            await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
            log("🧊 ICE candidate added successfully");
          } catch (e) {
            log("❌ ICE candidate error: " + e.message);
          }
        } else {
          log("⚠️ ICE candidate received but peer connection not ready");
        }
      });

      socket.on("call:accepted", ({ callId }) => {
        log("✅ Call was accepted by receiver");
        startAutoEndTimer();
      });

      socket.on("call:rejected", ({ callId }) => {
        log("❌ Call was rejected");
        resetCall();
      });

      socket.on("call:cancelled", ({ callId }) => {
        log("🛑 Call was cancelled");
        resetCall();
      });

      socket.on("call:ended", ({ callId, duration, status }) => {
        log(`📴 Call ended. Duration: ${duration}s, Status: ${status}`);
        document.getElementById("callIdHolder").textContent = "";
        resetCall();
      });
    }

    async function initiateCall() {
      const callerId = document.getElementById("userId").value.trim();
      const receiverId = document.getElementById("receiverId").value.trim();
      if (!callerId || !receiverId) return alert("Enter both caller and receiver IDs");

      try {
        isCallInitiator = true;
        callerSocketId = receiverId;

        socket.emit("call:initiated", { callerId, receiverId, callType: "video" });

        await startCamera();
        await createPeerConnection(receiverId);

        const offer = await peerConnection.createOffer({
          offerToReceiveAudio: true,
          offerToReceiveVideo: true
        });
        await peerConnection.setLocalDescription(offer);
        socket.emit("offer", { offer, to: receiverId });

        log("📤 Call initiated and offer sent");
      } catch (error) {
        log("❌ Error initiating call: " + error.message);
        resetCall();
      }
    }

    async function createPeerConnection(targetId) {
      if (peerConnection) {
        peerConnection.close();
      }

      peerConnection = new RTCPeerConnection(config);
      remoteStream = new MediaStream();
      log("🔗 Created new peer connection");

      peerConnection.onicecandidate = (event) => {
        if (event.candidate) {
          socket.emit("ice-candidate", { candidate: event.candidate, to: targetId });
          log("🧊 ICE candidate sent");
        }
      };

      peerConnection.ontrack = (event) => {
        remoteStream.addTrack(event.track);
        document.getElementById("remoteVideo").srcObject = remoteStream;
        log(`🎥 Remote ${event.track.kind} track added`);
      };

      peerConnection.onconnectionstatechange = () => {
        log(`🔗 Connection state: ${peerConnection.connectionState}`);
        if (peerConnection.connectionState === 'connected') {
          log("✅ Peer connection established successfully!");
        }
      };

      peerConnection.oniceconnectionstatechange = () => {
        log(`🧊 ICE connection state: ${peerConnection.iceConnectionState}`);
        if (peerConnection.iceConnectionState === 'connected') {
          log("✅ ICE connection successful!");
        }
      };

      if (localStream) {
        localStream.getTracks().forEach(track => {
          peerConnection.addTrack(track, localStream);
          log(`📹 Added local ${track.kind} track to peer connection`);
        });
      } else {
        log("❌ No local stream available to add tracks");
      }
    }

    async function acceptCall() {
      if (!currentCallId) return alert("No incoming call.");

      try {
        log("✅ Accepting call...");
        await startCamera();
        await createPeerConnection(callerSocketId);
        socket.emit("call:accepted", { callId: currentCallId });
        log("✅ Call accepted - peer connection should be active");
        startAutoEndTimer();
      } catch (error) {
        log("❌ Error accepting call: " + error.message);
      }
    }

    function rejectCall() {
      if (!currentCallId) return alert("No call to reject.");
      socket.emit("call:rejected", { callId: currentCallId });
      log("❌ Call rejected");
      resetCall();
    }

    function cancelCall() {
      if (!currentCallId) return alert("No call to cancel.");
      socket.emit("call:cancelled", { callId: currentCallId });
      log("🛑 Call cancelled");
      resetCall();
    }

    function endCall() {
      if (!currentCallId) return alert("No call to end.");
      socket.emit("call:ended", { callId: currentCallId });
      log("🛑 Ended the call");
      resetCall();
    }

    function resetCall() {
      currentCallId = null;
      if (peerConnection) peerConnection.close();
      peerConnection = null;
      document.getElementById("callIdHolder").textContent = "";
      clearTimeout(callTimer);
    }

    function startAutoEndTimer() {
      const durationInput = document.getElementById("callDuration");
      const minutes = parseInt(durationInput.value);
      if (isNaN(minutes) || minutes <= 0) return;

      const durationMs = minutes * 60 * 1000;
      callTimer = setTimeout(() => {
        endCall();
      }, durationMs);
    }

    async function startCamera() {
      if (localStream) {
        log("🎥 Camera already active");
        return;
      }

      try {
        localStream = await navigator.mediaDevices.getUserMedia({
          video: { width: 640, height: 480 },
          audio: true
        });
        document.getElementById("localVideo").srcObject = localStream;
        log("🎥 Camera & microphone access granted");
        log("🎥 Local stream tracks: " + localStream.getTracks().map(t => t.kind).join(", "));
      } catch (err) {
        log("❌ Failed to access camera/microphone: " + err.message);
        throw err;
      }
    }
  </script>
</body>
</html>
