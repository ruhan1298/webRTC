<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>WebRTC Video Call - Camera/Mic Controls</title>
  <script src="https://cdn.socket.io/4.6.1/socket.io.min.js"></script>
  <style>
  .chat-container {
  border: 1px solid #ccc;
  padding: 10px;
  width: 300px;
  max-height: 400px;
  overflow: hidden;
  display: flex;
  flex-direction: column;
}

.chat-msg {
    margin: 5px 0;
    padding: 8px 12px;
    border-radius: 12px;
    max-width: 80%;
    word-wrap: break-word;
    position: relative;
}

.chat-msg.self {
    background: #007bff;
    color: white;
    margin-left: auto;
    text-align: right;
}

.chat-msg.remote {
    background: #f1f1f1;
    color: #333;
    margin-right: auto;
}

.chat-time {
    font-size: 10px;
    opacity: 0.7;
    margin-left: 10px;
}
    body {
      font-family: Arial, sans-serif;
      max-width: 1400px;
      margin: 0 auto;
      padding: 20px;
      background: #f5f5f5;
    }
    .container {
      background: white;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    .video-container {
      display: flex;
      gap: 20px;
      margin: 20px 0;
      justify-content: center;
    }
    .video-box {
      flex: 1;
      max-width: 500px;
      position: relative;
    }
    .video-box h3 {
      margin: 0 0 10px 0;
      padding: 10px;
      background: #f0f0f0;
      border-radius: 5px;
      text-align: center;
    }
    video {
      width: 100%;
      height: 300px;
      background: #000;
      border: 2px solid #ddd;
      border-radius: 8px;
      object-fit: cover;
    }
    .video-controls {
      position: absolute;
      bottom: 15px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
      z-index: 10;
    }
    .control-btn {
      width: 50px;
      height: 50px;
      border-radius: 50%;
      border: none;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      transition: all 0.3s ease;
      box-shadow: 0 2px 10px rgba(0,0,0,0.3);
    }
    .control-btn.video-on {
      background: #4285f4;
      color: white;
    }
    .control-btn.video-off {
      background: #ea4335;
      color: white;
    }
    .control-btn.audio-on {
      background: #34a853;
      color: white;
    }
    .control-btn.audio-off {
      background: #ea4335;
      color: white;
    }
    .control-btn:hover {
      transform: scale(1.1);
    }
    .video-off-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: #2d2d2d;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 18px;
      border-radius: 8px;
      z-index: 5;
    }
    .video-off-overlay .icon {
      font-size: 48px;
      margin-bottom: 10px;
    }
    .audio-muted-indicator {
      position: absolute;
      top: 15px;
      right: 15px;
      background: rgba(234, 67, 53, 0.9);
      color: white;
      padding: 8px 12px;
      border-radius: 20px;
      font-size: 14px;
      z-index: 10;
      display: none;
    }
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      margin: 10px 0;
      padding: 15px;
      background: #f8f9fa;
      border-radius: 8px;
    }
    .controls input {
      padding: 8px 12px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
    }
    .controls button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
    }
    .btn-primary { background: #007bff; color: white; }
    .btn-success { background: #28a745; color: white; }
    .btn-danger { background: #dc3545; color: white; }
    .btn-warning { background: #ffc107; color: black; }
    .btn-secondary { background: #6c757d; color: white; }
    
    .status {
      font-weight: bold;
      padding: 12px;
      border-radius: 6px;
      margin: 10px 0;
      text-align: center;
    }
    .status.connecting { background: #cce5ff; color: #0066cc; }
    .status.connected { background: #d4edda; color: #155724; }
    .status.error { background: #f8d7da; color: #721c24; }
    .status.warning { background: #fff3cd; color: #856404; }
    
    #logs {
      background: #1a1a1a;
      color: #00ff00;
      padding: 15px;
      border-radius: 6px;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      max-height: 250px;
      overflow-y: auto;
      white-space: pre-wrap;
      margin: 20px 0;
    }
    .call-info {
      background: #e3f2fd;
      padding: 10px;
      border-left: 4px solid #2196f3;
      margin: 10px 0;
      border-radius: 4px;
    }
    .permission-box {
      background: #fffbf2;
      border: 2px dashed #ff9800;
      padding: 15px;
      border-radius: 8px;
      margin: 10px 0;
      text-align: center;
    }
    .permission-granted {
      background: #f0f8f0;
      border: 2px solid #4caf50;
    }
  </style>
</head>
<body>
  <div class="container">
    <h2>üìû WebRTC Video Call - Camera/Mic Controls</h2>

    <!-- Permission Status -->
    <div id="permissionStatus" class="permission-box">
      üé• Click "Test Camera" to grant permissions first
    </div>

    <div class="controls">
      <button class="btn-warning" onclick="testCameraPermission()">üé• Test Camera</button>
      <div>
        <label>Your User ID:</label>
        <input type="text" id="userId" placeholder="Enter your unique ID" />
        <button class="btn-primary" onclick="connectUser()">üîå Connect</button>
      </div>
      
      <div>
        <label>Call User ID:</label>
        <input type="text" id="receiverId" placeholder="Enter user ID to call" />
      </div>
      
      <div>
        <label>Duration:</label>
        <input type="number" id="callDuration" value="2" min="1" max="30" style="width: 60px;" /> minutes
      </div>
    </div>

    <div class="controls">
      <button class="btn-success" onclick="initiateCall()">üìû Start Call</button>
      <button class="btn-success" onclick="acceptCall()">‚úÖ Accept Call</button>
      <button class="btn-danger" onclick="rejectCall()">‚ùå Reject Call</button>
      <button class="btn-warning" onclick="cancelCall()">üõë Cancel Call</button>
      <button class="btn-secondary" onclick="endCall()">üì¥ End Call</button>
    </div>

    <div id="status" class="status">Status: Not connected</div>
    <div id="callIdHolder" class="call-info" style="display:none;"></div>

    <div class="video-container">
      <div class="video-box">
        <h3>üé• Your Video</h3>
        <video id="localVideo" autoplay playsinline muted></video>
        <div id="localVideoOff" class="video-off-overlay" style="display: none;">
          <div class="icon">üìπ</div>
          <div>Camera is off</div>
        </div>
        <div id="localAudioMuted" class="audio-muted-indicator">üîá Muted</div>
        <div class="video-controls">
          <button id="localVideoBtn" class="control-btn video-off" onclick="toggleLocalVideo()" title="Turn camera on/off">
            üìπ
          </button>
          <button id="localAudioBtn" class="control-btn audio-off" onclick="toggleLocalAudio()" title="Turn microphone on/off">
            üé§
          </button>
        </div>
        <div style="text-align: center; margin-top: 5px; font-size: 12px;" id="localStatus">Camera off</div>
      </div>
      <div class="video-box">
        <h3>üé• Remote Video</h3>
        <video id="remoteVideo" autoplay playsinline></video>
        <div id="remoteVideoOff" class="video-off-overlay" style="display: none;">
          <div class="icon">üìπ</div>
          <div>Remote camera is off</div>
        </div>
        <div id="remoteAudioMuted" class="audio-muted-indicator">üîá Remote muted</div>
        <div style="text-align: center; margin-top: 5px; font-size: 12px;" id="remoteStatus">Waiting for connection</div>
      </div>
    </div>
    <div id="chatBox" class="chat-container">
  <div id="chatMessages" class="chat-messages"></div>
  <input type="text" id="chatInput" placeholder="Type a message..." />
  <button onclick="sendChatMessage()">Send</button>
</div>


    <div id="logs"></div>
  </div>

  <script>
    let socket;
let peerConnection;
let localStream;
let currentCallId = null;
let targetUserId = null;
let callTimer;
let isCallInitiator = false;
let permissionGranted = false;
let iceCandidateQueue = [];

// Media state tracking
let localVideoEnabled = false;
let localAudioEnabled = false;
let remoteVideoEnabled = true;
let remoteAudioEnabled = true;

const config = {
    iceServers: [
        { urls: "stun:stun.l.google.com:19302" },
        { urls: "stun:stun1.l.google.com:19302" },
        { urls: "stun:stun.services.mozilla.com" },
        { urls: "stun:stun2.l.google.com:19302" }
    ],
    iceCandidatePoolSize: 10
};

function log(msg) {
    const logs = document.getElementById("logs");
    const timestamp = new Date().toLocaleTimeString();
    logs.textContent += `[${timestamp}] ${msg}\n`;
    logs.scrollTop = logs.scrollHeight;
    console.log(`[WebRTC] ${msg}`);
}

function updateStatus(text, className = "") {
    const statusEl = document.getElementById("status");
    statusEl.textContent = text;
    statusEl.className = `status ${className}`;
}

function updateLocalStatus(text) {
    document.getElementById("localStatus").textContent = text;
}

function updateRemoteStatus(text) {
    document.getElementById("remoteStatus").textContent = text;
}

function updatePermissionStatus(text, granted = false) {
    const permEl = document.getElementById("permissionStatus");
    permEl.textContent = text;
    if (granted) {
        permEl.className = "permission-box permission-granted";
    } else {
        permEl.className = "permission-box";
    }
}

// Media control functions
function toggleLocalVideo() {
    if (!localStream) {
        alert("Please start camera first!");
        return;
    }

    const videoTrack = localStream.getVideoTracks()[0];
    if (videoTrack) {
        localVideoEnabled = !localVideoEnabled;
        videoTrack.enabled = localVideoEnabled;
        
        // Update UI
        const btn = document.getElementById("localVideoBtn");
        const overlay = document.getElementById("localVideoOff");
        
        if (localVideoEnabled) {
            btn.className = "control-btn video-on";
            btn.innerHTML = "üìπ";
            overlay.style.display = "none";
            updateLocalStatus("Camera on");
        } else {
            btn.className = "control-btn video-off";
            btn.innerHTML = "üìπ";
            overlay.style.display = "flex";
            updateLocalStatus("Camera off");
        }

        // Notify remote user
        if (socket && targetUserId) {
            socket.emit("media-state", {
                to: targetUserId,
                video: localVideoEnabled,
                audio: localAudioEnabled
            });
        }

        log(`üìπ Local video ${localVideoEnabled ? 'enabled' : 'disabled'}`);
    }
}

function toggleLocalAudio() {
    if (!localStream) {
        alert("Please start camera first!");
        return;
    }

    const audioTrack = localStream.getAudioTracks()[0];
    if (audioTrack) {
        localAudioEnabled = !localAudioEnabled;
        audioTrack.enabled = localAudioEnabled;
        
        // Update UI
        const btn = document.getElementById("localAudioBtn");
        const indicator = document.getElementById("localAudioMuted");
        
        if (localAudioEnabled) {
            btn.className = "control-btn audio-on";
            btn.innerHTML = "üé§";
            indicator.style.display = "none";
        } else {
            btn.className = "control-btn audio-off";
            btn.innerHTML = "üé§";
            indicator.style.display = "block";
        }

        // Notify remote user
        if (socket && targetUserId) {
            socket.emit("media-state", {
                to: targetUserId,
                video: localVideoEnabled,
                audio: localAudioEnabled
            });
        }

        log(`üé§ Local audio ${localAudioEnabled ? 'enabled' : 'disabled'}`);
    }
}

function updateRemoteMediaState(video, audio) {
    remoteVideoEnabled = video;
    remoteAudioEnabled = audio;

    // Update remote video display
    const remoteVideoOverlay = document.getElementById("remoteVideoOff");
    const remoteAudioIndicator = document.getElementById("remoteAudioMuted");

    if (remoteVideoEnabled) {
        remoteVideoOverlay.style.display = "none";
    } else {
        remoteVideoOverlay.style.display = "flex";
    }

    if (remoteAudioEnabled) {
        remoteAudioIndicator.style.display = "none";
    } else {
        remoteAudioIndicator.style.display = "block";
    }

    log(`üì° Remote media state - Video: ${video ? 'on' : 'off'}, Audio: ${audio ? 'on' : 'off'}`);
}

// Test camera permission function
async function testCameraPermission() {
    try {
        updatePermissionStatus("üé• Testing camera permission...", false);
        log("üé• Testing camera access...");

        if (localStream) {
            localStream.getTracks().forEach(track => track.stop());
            localStream = null;
        }

        localStream = await navigator.mediaDevices.getUserMedia({
            video: {
                width: { ideal: 640, max: 1280 },
                height: { ideal: 480, max: 720 },
                facingMode: 'user'
            },
            audio: {
                echoCancellation: true,
                noiseSuppression: true,
                autoGainControl: true
            }
        });

        const localVideo = document.getElementById("localVideo");
        localVideo.srcObject = localStream;
        
        // Initially turn off video and audio
        localVideoEnabled = false;
        localAudioEnabled = false;
        
        const videoTrack = localStream.getVideoTracks()[0];
        const audioTrack = localStream.getAudioTracks()[0];
        
        if (videoTrack) videoTrack.enabled = false;
        if (audioTrack) audioTrack.enabled = false;
        
        // Update UI to show off state
        document.getElementById("localVideoBtn").className = "control-btn video-off";
        document.getElementById("localAudioBtn").className = "control-btn audio-off";
        document.getElementById("localVideoOff").style.display = "flex";
        document.getElementById("localAudioMuted").style.display = "block";
        
        updateLocalStatus("Camera & mic ready (off)");
        updatePermissionStatus("‚úÖ Camera & Microphone permissions granted! Ready for calls.", true);
        
        permissionGranted = true;
        log(`‚úÖ Camera permission granted - ${localStream.getTracks().length} tracks available (initially off)`);
        
    } catch (error) {
        log(`‚ùå Camera permission error: ${error.message}`);
        updatePermissionStatus("‚ùå Camera permission denied. Please allow camera access!", false);
        updateLocalStatus("Permission denied");
        alert(`Camera access failed: ${error.message}\n\nPlease:\n1. Allow camera permission\n2. Refresh page if needed`);
        permissionGranted = false;
    }
}

async function connectUser() {
    const userId = document.getElementById("userId").value.trim();
    if (!userId) return alert("Please enter your User ID first!");

    if (!permissionGranted) {
        alert("Please test camera permission first!");
        return;
    }

    if (socket) {
        socket.disconnect();
    }

    // For demo purposes, we'll simulate a socket connection
    socket = {
        connected: true,
        id: 'demo-socket-' + Math.random().toString(36).substr(2, 9),
        emit: function(event, data) {
            log(`üì§ Socket emit: ${event} - ${JSON.stringify(data)}`);
        },
        on: function(event, callback) {
            log(`üì• Socket listener registered: ${event}`);
        },
        disconnect: function() {
            this.connected = false;
            log("üîå Socket disconnected");
        }
    };

    log(`‚úÖ Connected to server with socket ID: ${socket.id}`);
    updateStatus("‚úÖ Connected to server (demo mode)", "connected");
    log(`üìù Registered as user: ${userId}`);
}

async function initiateCall() {
    const callerId = document.getElementById("userId").value.trim();
    const receiverId = document.getElementById("receiverId").value.trim();
    
    if (!callerId || !receiverId) {
        return alert("Please enter both User IDs!");
    }
    
    if (!socket || !socket.connected) {
        return alert("Please connect to server first!");
    }

    if (!permissionGranted || !localStream) {
        alert("Please test camera permission first!");
        return;
    }

    try {
        log(`üìû Starting video call to ${receiverId}...`);
        updateStatus("üìû Initiating call...", "connecting");
        
        isCallInitiator = true;
        targetUserId = receiverId;

        await createPeerConnection();
        log("üîó Peer connection created with local stream");

        const offer = await peerConnection.createOffer({
            offerToReceiveAudio: true,
            offerToReceiveVideo: true
        });
        
        await peerConnection.setLocalDescription(offer);
        log("üì° Local description set with offer");

        log("üì§ Offer sent to remote user");
        updateStatus("üì§ Calling... (Camera ready)", "connecting");

        // Simulate call acceptance for demo
        setTimeout(() => {
            log("‚úÖ Call accepted (demo)");
            updateStatus("‚úÖ Call Active", "connected");
            startAutoEndTimer();
        }, 2000);

    } catch (error) {
        log(`‚ùå Error initiating call: ${error.message}`);
        updateStatus("‚ùå Call failed", "error");
        resetCall();
    }
}

async function createPeerConnection() {
    try {
        peerConnection = new RTCPeerConnection(config);
        
        // Add local stream tracks
        if (localStream) {
            localStream.getTracks().forEach(track => {
                peerConnection.addTrack(track, localStream);
                log(`‚ûï Added ${track.kind} track to peer connection`);
            });
        } else {
            log("‚ö†Ô∏è No local stream available");
        }

        // Handle incoming stream
        peerConnection.ontrack = (event) => {
            log(`üì• Received remote ${event.track.kind} track`);
            const remoteVideo = document.getElementById("remoteVideo");
            if (event.streams && event.streams[0]) {
                remoteVideo.srcObject = event.streams[0];
                updateRemoteStatus("Remote video connected");
                log("üì∫ Remote video stream set");
            }
        };

        // Handle ICE candidates
        peerConnection.onicecandidate = (event) => {
            if (event.candidate) {
                log("üßä Generated ICE candidate");
                if (socket && targetUserId) {
                    socket.emit("ice-candidate", {
                        candidate: event.candidate,
                        to: targetUserId
                    });
                }
            } else {
                log("üßä ICE candidate gathering complete");
            }
        };

        // Handle connection state changes
        peerConnection.onconnectionstatechange = () => {
            const state = peerConnection.connectionState;
            log(`üîó Connection state: ${state}`);
            
            switch (state) {
                case 'connected':
                    updateStatus("‚úÖ Connected", "connected");
                    break;
                case 'disconnected':
                    updateStatus("üîå Disconnected", "warning");
                    break;
                case 'failed':
                    updateStatus("‚ùå Connection failed", "error");
                    resetCall();
                    break;
            }
        };

        log("üîó Peer connection created successfully");
        return peerConnection;

    } catch (error) {
        log(`‚ùå Error creating peer connection: ${error.message}`);
        throw error;
    }
}

async function processIceCandidateQueue() {
    while (iceCandidateQueue.length > 0) {
        const candidate = iceCandidateQueue.shift();
        try {
            await peerConnection.addIceCandidate(candidate);
            log("üßä Processed queued ICE candidate");
        } catch (error) {
            log(`‚ùå Error processing ICE candidate: ${error.message}`);
        }
    }
}

async function handleAnswer(answer) {
    try {
        await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
        log("üì° Remote description set from answer");
        
        await processIceCandidateQueue();
        
        updateStatus("üì° Connection established", "connected");
        log("‚úÖ WebRTC connection established");

    } catch (error) {
        log(`‚ùå Error handling answer: ${error.message}`);
        updateStatus("‚ùå Connection failed", "error");
    }
}

// Complete the missing handleIceCandidate function
async function handleIceCandidate(candidate) {
    try {
        if (peerConnection && peerConnection.remoteDescription) {
            await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
            log("üßä Added ICE candidate");
        } else {
            log("üßä Queuing ICE candidate (no remote description yet)");
            iceCandidateQueue.push(new RTCIceCandidate(candidate));
        }
    } catch (error) {
        log(`‚ùå Error handling ICE candidate: ${error.message}`);
    }
}

// Handle incoming call offer
async function handleOffer(offer, callerId) {
    try {
        log(`üìû Incoming call from ${callerId}`);
        
        if (!permissionGranted || !localStream) {
            log("‚ùå Camera permission not granted, cannot accept call");
            return;
        }

        isCallInitiator = false;
        targetUserId = callerId;
        
        await createPeerConnection();
        
        await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
        log("üì° Remote description set from offer");
        
        const answer = await peerConnection.createAnswer();
        await peerConnection.setLocalDescription(answer);
        log("üì° Local description set with answer");
        
        // Send answer back
        if (socket) {
            socket.emit("call-answer", {
                answer: answer,
                to: callerId
            });
        }
        
        await processIceCandidateQueue();
        
        updateStatus("üìû Call accepted", "connected");
        log("‚úÖ Call accepted and answer sent");
        
    } catch (error) {
        log(`‚ùå Error handling call offer: ${error.message}`);
        updateStatus("‚ùå Call failed", "error");
    }
}

// End call function
function endCall() {
    log("üì¥ Ending call...");
    
    if (callTimer) {
        clearInterval(callTimer);
        callTimer = null;
    }
    
    if (peerConnection) {
        peerConnection.close();
        peerConnection = null;
    }
    
    if (socket && targetUserId) {
        socket.emit("call-end", { to: targetUserId });
    }
    
    resetCall();
    updateStatus("üì¥ Call ended", "warning");
    log("‚úÖ Call ended successfully");
}

// Reset call state
function resetCall() {
    currentCallId = null;
    targetUserId = null;
    isCallInitiator = false;
    iceCandidateQueue = [];
    
    // Clear remote video
    const remoteVideo = document.getElementById("remoteVideo");
    if (remoteVideo) {
        remoteVideo.srcObject = null;
    }
    
    updateRemoteStatus("No remote connection");
    
    // Reset remote media indicators
    const remoteVideoOverlay = document.getElementById("remoteVideoOff");
    const remoteAudioIndicator = document.getElementById("remoteAudioMuted");
    
    if (remoteVideoOverlay) remoteVideoOverlay.style.display = "flex";
    if (remoteAudioIndicator) remoteAudioIndicator.style.display = "none";
    
    if (callTimer) {
        clearInterval(callTimer);
        callTimer = null;
    }
}

// Auto-end timer for demo purposes
function startAutoEndTimer() {
    let seconds = 0;
    callTimer = setInterval(() => {
        seconds++;
        const minutes = Math.floor(seconds / 60);
        const remainingSeconds = seconds % 60;
        const timeString = `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
        
        // Update call duration display if element exists
        const durationEl = document.getElementById("callDuration");
        if (durationEl) {
            durationEl.textContent = `Call Duration: ${timeString}`;
        }
        
        // Auto-end after 30 seconds for demo
        if (seconds >= 30) {
            log("‚è∞ Demo call auto-ending after 30 seconds");
            endCall();
        }
    }, 1000);
}

// Initialize on page load
document.addEventListener('DOMContentLoaded', function() {
    log("üöÄ WebRTC Video Call App initialized");
    updateStatus("üîå Ready to connect", "ready");
    updateLocalStatus("Camera not started");
    updateRemoteStatus("No remote connection");
    updatePermissionStatus("üì∑ Camera permission not tested", false);
});


  </script>
</body>
</html>