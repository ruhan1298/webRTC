<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>WebRTC Video Call - Auto Permission Fix</title>
  <script src="https://cdn.socket.io/4.6.1/socket.io.min.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 1400px;
      margin: 0 auto;
      padding: 20px;
      background: #f5f5f5;
    }
    .container {
      background: white;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    .video-container {
      display: flex;
      gap: 20px;
      margin: 20px 0;
      justify-content: center;
    }
    .video-box {
      flex: 1;
      max-width: 500px;
    }
    .video-box h3 {
      margin: 0 0 10px 0;
      padding: 10px;
      background: #f0f0f0;
      border-radius: 5px;
      text-align: center;
    }
    video {
      width: 100%;
      height: 300px;
      background: #000;
      border: 2px solid #ddd;
      border-radius: 8px;
      object-fit: cover;
    }
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      margin: 10px 0;
      padding: 15px;
      background: #f8f9fa;
      border-radius: 8px;
    }
    .controls input {
      padding: 8px 12px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
    }
    .controls button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
    }
    .btn-primary { background: #007bff; color: white; }
    .btn-success { background: #28a745; color: white; }
    .btn-danger { background: #dc3545; color: white; }
    .btn-warning { background: #ffc107; color: black; }
    .btn-secondary { background: #6c757d; color: white; }
    
    .status {
      font-weight: bold;
      padding: 12px;
      border-radius: 6px;
      margin: 10px 0;
      text-align: center;
    }
    .status.connecting { background: #cce5ff; color: #0066cc; }
    .status.connected { background: #d4edda; color: #155724; }
    .status.error { background: #f8d7da; color: #721c24; }
    .status.warning { background: #fff3cd; color: #856404; }
    
    #logs {
      background: #1a1a1a;
      color: #00ff00;
      padding: 15px;
      border-radius: 6px;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      max-height: 250px;
      overflow-y: auto;
      white-space: pre-wrap;
      margin: 20px 0;
    }
    .call-info {
      background: #e3f2fd;
      padding: 10px;
      border-left: 4px solid #2196f3;
      margin: 10px 0;
      border-radius: 4px;
    }
    .permission-box {
      background: #fffbf2;
      border: 2px dashed #ff9800;
      padding: 15px;
      border-radius: 8px;
      margin: 10px 0;
      text-align: center;
    }
    .permission-granted {
      background: #f0f8f0;
      border: 2px solid #4caf50;
    }
  </style>
</head>
<body>
  <div class="container">
    <h2>ğŸ“ WebRTC Video Call - Auto Permission Fix</h2>

    <!-- Permission Status -->
    <div id="permissionStatus" class="permission-box">
      ğŸ¥ Click "Test Camera" to grant permissions first
    </div>

    <div class="controls">
      <button class="btn-warning" onclick="testCameraPermission()">ğŸ¥ Test Camera</button>
      <div>
        <label>Your User ID:</label>
        <input type="text" id="userId" placeholder="Enter your unique ID" />
        <button class="btn-primary" onclick="connectUser()">ğŸ”Œ Connect</button>
      </div>
      
      <div>
        <label>Call User ID:</label>
        <input type="text" id="receiverId" placeholder="Enter user ID to call" />
      </div>
      
      <div>
        <label>Duration:</label>
        <input type="number" id="callDuration" value="2" min="1" max="30" style="width: 60px;" /> minutes
      </div>
    </div>

    <div class="controls">
      <button class="btn-success" onclick="initiateCall()">ğŸ“ Start Call</button>
      <button class="btn-success" onclick="acceptCall()">âœ… Accept Call</button>
      <button class="btn-danger" onclick="rejectCall()">âŒ Reject Call</button>
      <button class="btn-warning" onclick="cancelCall()">ğŸ›‘ Cancel Call</button>
      <button class="btn-secondary" onclick="endCall()">ğŸ“´ End Call</button>
    </div>

    <div id="status" class="status">Status: Not connected</div>
    <div id="callIdHolder" class="call-info" style="display:none;"></div>

    <div class="video-container">
      <div class="video-box">
        <h3>ğŸ¥ Your Video</h3>
        <video id="localVideo" autoplay playsinline muted></video>
        <div style="text-align: center; margin-top: 5px; font-size: 12px;" id="localStatus">Camera off</div>
      </div>
      <div class="video-box">
        <h3>ğŸ¥ Remote Video</h3>
        <video id="remoteVideo" autoplay playsinline></video>
        <div style="text-align: center; margin-top: 5px; font-size: 12px;" id="remoteStatus">Waiting for connection</div>
      </div>
    </div>

    <div id="logs"></div>
  </div>

  <script>
    let socket;
    let peerConnection;
    let localStream;
    let currentCallId = null;
    let targetUserId = null;
    let callTimer;
    let isCallInitiator = false;
    let permissionGranted = false;

    const config = {
      iceServers: [
        { urls: "stun:stun.l.google.com:19302" },
        { urls: "stun:stun1.l.google.com:19302" },
        { urls: "stun:stun.services.mozilla.com" }
      ]
    };

    function log(msg) {
      const logs = document.getElementById("logs");
      const timestamp = new Date().toLocaleTimeString();
      logs.textContent += `[${timestamp}] ${msg}\n`;
      logs.scrollTop = logs.scrollHeight;
      console.log(`[WebRTC] ${msg}`);
    }

    function updateStatus(text, className = "") {
      const statusEl = document.getElementById("status");
      statusEl.textContent = text;
      statusEl.className = `status ${className}`;
    }

    function updateLocalStatus(text) {
      document.getElementById("localStatus").textContent = text;
    }

    function updateRemoteStatus(text) {
      document.getElementById("remoteStatus").textContent = text;
    }

    function updatePermissionStatus(text, granted = false) {
      const permEl = document.getElementById("permissionStatus");
      permEl.textContent = text;
      if (granted) {
        permEl.className = "permission-box permission-granted";
      } else {
        permEl.className = "permission-box";
      }
    }

    // Test camera permission function
    async function testCameraPermission() {
      try {
        updatePermissionStatus("ğŸ¥ Testing camera permission...", false);
        log("ğŸ¥ Testing camera access...");

        if (localStream) {
          localStream.getTracks().forEach(track => track.stop());
          localStream = null;
        }

        localStream = await navigator.mediaDevices.getUserMedia({
          video: {
            width: { ideal: 640, max: 1280 },
            height: { ideal: 480, max: 720 },
            facingMode: 'user'
          },
          audio: {
            echoCancellation: true,
            noiseSuppression: true,
            autoGainControl: true
          }
        });

        const localVideo = document.getElementById("localVideo");
        localVideo.srcObject = localStream;
        updateLocalStatus(`Camera active (${localStream.getTracks().length} tracks)`);
        updatePermissionStatus("âœ… Camera & Microphone permissions granted! Ready for calls.", true);
        
        permissionGranted = true;
        log(`âœ… Camera permission granted - ${localStream.getTracks().length} tracks available`);
        
        // Show track details
        localStream.getTracks().forEach(track => {
          log(`ğŸ“¹ Track ready: ${track.kind} - ${track.label}`);
        });

      } catch (error) {
        log(`âŒ Camera permission error: ${error.message}`);
        updatePermissionStatus("âŒ Camera permission denied. Please allow camera access!", false);
        updateLocalStatus("Permission denied");
        alert(`Camera access failed: ${error.message}\n\nPlease:\n1. Allow camera permission\n2. Refresh page if needed`);
        permissionGranted = false;
      }
    }

    async function connectUser() {
      const userId = document.getElementById("userId").value.trim();
      if (!userId) return alert("Please enter your User ID first!");

      if (!permissionGranted) {
        alert("Please test camera permission first!");
        return;
      }

      if (socket) {
        socket.disconnect();
      }

      socket = io("https://webrtc-1-pi3s.onrender.com/");

      socket.on("connect", () => {
        log(`âœ… Connected to server with socket ID: ${socket.id}`);
        updateStatus("âœ… Connected to server", "connected");
        socket.emit("register", userId);
        log(`ğŸ“ Registered as user: ${userId}`);
      });

      socket.on("call:incoming", async ({ callerId, callType, callId, socketId }) => {
        currentCallId = callId;
        targetUserId = callerId;
        isCallInitiator = false;
        
        log(`ğŸ“ Incoming ${callType} call from ${callerId}`);
        updateStatus(`ğŸ“ Incoming call from ${callerId}`, "warning");
        
        const callInfo = document.getElementById("callIdHolder");
        callInfo.innerHTML = `ğŸ“ <strong>Incoming call from: ${callerId}</strong><br>ğŸ¥ Your camera will auto-start when you accept`;
        callInfo.style.display = "block";
      });

      socket.on("offer", async ({ offer, from }) => {
        log(`ğŸ“¡ Received offer from: ${from}`);
        await handleOffer(offer, from);
      });

      socket.on("answer", async ({ answer, from }) => {
        log(`ğŸ“¡ Received answer from: ${from}`);
        await handleAnswer(answer);
      });

      socket.on("ice-candidate", async ({ candidate, from }) => {
        log(`ğŸ§Š Received ICE candidate from: ${from}`);
        await handleIceCandidate(candidate);
      });

      socket.on("call:accepted", ({ callId }) => {
        log("âœ… Call accepted by remote user");
        updateStatus("âœ… Call Active - Both cameras connected", "connected");
        startAutoEndTimer();
      });

      socket.on("call:rejected", ({ callId }) => {
        log("âŒ Call rejected by remote user");
        updateStatus("âŒ Call Rejected", "error");
        resetCall();
      });

      socket.on("call:cancelled", ({ callId }) => {
        log("ğŸ›‘ Call cancelled");
        updateStatus("ğŸ›‘ Call Cancelled", "warning");
        resetCall();
      });

      socket.on("call:ended", ({ callId, duration, status }) => {
        log(`ğŸ“´ Call ended - Duration: ${duration}s`);
        updateStatus("ğŸ“´ Call Ended", "");
        resetCall();
      });

      socket.on("disconnect", () => {
        log("âŒ Disconnected from server");
        updateStatus("âŒ Disconnected", "error");
      });
    }

    async function initiateCall() {
      const callerId = document.getElementById("userId").value.trim();
      const receiverId = document.getElementById("receiverId").value.trim();
      
      if (!callerId || !receiverId) {
        return alert("Please enter both User IDs!");
      }
      
      if (!socket || !socket.connected) {
        return alert("Please connect to server first!");
      }

      if (!permissionGranted || !localStream) {
        alert("Please test camera permission first!");
        return;
      }

      try {
        log(`ğŸ“ Starting video call to ${receiverId}...`);
        updateStatus("ğŸ“ Initiating call...", "connecting");
        
        isCallInitiator = true;
        targetUserId = receiverId;

        // Create peer connection with existing stream
        await createPeerConnection();
        log("ğŸ”— Peer connection created with local stream");

        // Create offer
        const offer = await peerConnection.createOffer({
          offerToReceiveAudio: true,
          offerToReceiveVideo: true
        });
        
        await peerConnection.setLocalDescription(offer);
        log("ğŸ“¡ Local description set with offer");

        // Send call initiation and offer
        socket.emit("call:initiated", { callerId, receiverId, callType: "video" });
        socket.emit("offer", { offer, to: receiverId });
        
        log("ğŸ“¤ Offer sent to remote user");
        updateStatus("ğŸ“¤ Calling... (Camera ready)", "connecting");

      } catch (error) {
        log(`âŒ Error initiating call: ${error.message}`);
        updateStatus("âŒ Call failed", "error");
        resetCall();
      }
    }

    async function handleOffer(offer, from) {
      try {
        targetUserId = from;
        
        // Ensure camera is ready
        if (!localStream) {
          await startCamera();
          log("ğŸ“¹ Camera started for incoming call");
        }

        // Create peer connection
        await createPeerConnection();
        log("ğŸ”— Peer connection created for incoming call");

        // Set remote description
        await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
        log("ğŸ“¡ Remote description set from offer");

        // Create answer
        const answer = await peerConnection.createAnswer({
          offerToReceiveAudio: true,
          offerToReceiveVideo: true
        });
        
        await peerConnection.setLocalDescription(answer);
        log("ğŸ“¡ Local description set with answer");

        // Send answer
        socket.emit("answer", { answer, to: from });
        log("ğŸ“¤ Answer sent to caller");

      } catch (error) {
        log(`âŒ Error handling offer: ${error.message}`);
        updateStatus("âŒ Call setup failed", "error");
      }
    }

    async function handleAnswer(answer) {
      try {
        await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
        log("ğŸ“¡ Remote description set from answer - Connection establishing...");
        updateStatus("ğŸ“¡ Connecting streams...", "connecting");
      } catch (error) {
        log(`âŒ Error handling answer: ${error.message}`);
      }
    }

    async function handleIceCandidate(candidate) {
      try {
        if (peerConnection && peerConnection.remoteDescription) {
          await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
          log("ğŸ§Š ICE candidate added - Connection improving");
        } else {
          log("âš ï¸ ICE candidate queued (waiting for remote description)");
        }
      } catch (error) {
        log(`âŒ ICE candidate error: ${error.message}`);
      }
    }

    async function createPeerConnection() {
      if (peerConnection) {
        peerConnection.close();
        log("ğŸ”— Closed existing peer connection");
      }

      peerConnection = new RTCPeerConnection(config);
      log("ğŸ”— New peer connection created");

      // Ensure we have local stream
      if (!localStream) {
        await startCamera();
      }

      // Add local stream tracks
      if (localStream) {
        localStream.getTracks().forEach(track => {
          peerConnection.addTrack(track, localStream);
          log(`ğŸ“¹ Added ${track.kind} track to peer connection`);
        });
      }

      // Handle incoming remote stream
      peerConnection.ontrack = (event) => {
        log(`ğŸ¥ Received remote ${event.track.kind} track`);
        
        const remoteVideo = document.getElementById("remoteVideo");
        
        if (event.streams && event.streams[0]) {
          log("ğŸ¥ Setting remote stream to video element");
          remoteVideo.srcObject = event.streams[0];
          updateRemoteStatus("Remote video connecting...");
          
          // Force play with better error handling
          remoteVideo.play()
            .then(() => {
              log("ğŸ¥ Remote video playing successfully");
              updateRemoteStatus("Remote video active");
            })
            .catch(e => {
              log(`Remote video play error: ${e.message}`);
              updateRemoteStatus("Remote video error");
              // Try again after a short delay
              setTimeout(() => {
                remoteVideo.play().catch(() => {});
              }, 1000);
            });
        }
      };

      // ICE candidate handling
      peerConnection.onicecandidate = (event) => {
        if (event.candidate && targetUserId) {
          socket.emit("ice-candidate", { candidate: event.candidate, to: targetUserId });
          log(`ğŸ§Š Sent ICE candidate: ${event.candidate.type}`);
        }
      };

      // Connection state monitoring
      peerConnection.onconnectionstatechange = () => {
        const state = peerConnection.connectionState;
        log(`ğŸ”— Connection state: ${state}`);
        
        switch (state) {
          case 'connecting':
            updateStatus("ğŸ”— Connecting both cameras...", "connecting");
            break;
          case 'connected':
            updateStatus("âœ… Both cameras connected!", "connected");
            updateRemoteStatus("Connected & active");
            break;
          case 'disconnected':
            updateStatus("âš ï¸ Connection lost", "warning");
            updateRemoteStatus("Disconnected");
            break;
          case 'failed':
            updateStatus("âŒ Connection failed", "error");
            updateRemoteStatus("Connection failed");
            setTimeout(resetCall, 3000);
            break;
        }
      };

      peerConnection.oniceconnectionstatechange = () => {
        const iceState = peerConnection.iceConnectionState;
        log(`ğŸ§Š ICE connection state: ${iceState}`);
        
        if (iceState === 'connected' || iceState === 'completed') {
          log("ğŸ‰ ICE connection established - Video should be flowing!");
        }
      };
    }

    async function startCamera() {
      if (localStream) {
        log("ğŸ¥ Camera already active");
        return;
      }

      try {
        log("ğŸ¥ Starting camera for call...");
        updateLocalStatus("Starting camera...");

        localStream = await navigator.mediaDevices.getUserMedia({
          video: {
            width: { ideal: 640, max: 1280 },
            height: { ideal: 480, max: 720 },
            facingMode: 'user'
          },
          audio: {
            echoCancellation: true,
            noiseSuppression: true,
            autoGainControl: true
          }
        });

        const localVideo = document.getElementById("localVideo");
        localVideo.srcObject = localStream;
        updateLocalStatus(`Camera active (${localStream.getTracks().length} tracks)`);
        
        // Force play local video
        localVideo.play().catch(e => log(`Local video play error: ${e.message}`));

        log(`ğŸ¥ Camera started successfully - ${localStream.getTracks().length} tracks`);

      } catch (error) {
        log(`âŒ Camera error: ${error.message}`);
        updateLocalStatus("Camera failed");
        alert(`Camera access failed: ${error.message}`);
        throw error;
      }
    }

    async function acceptCall() {
      if (!currentCallId) {
        return alert("No incoming call to accept!");
      }

      try {
        log("âœ… Accepting call...");
        
        // Make sure camera is ready
        if (!localStream) {
          updateStatus("ğŸ“¹ Starting camera for call...", "connecting");
          await startCamera();
        }
        
        socket.emit("call:accepted", { callId: currentCallId });
        updateStatus("âœ… Call accepted - Connecting...", "connected");
        startAutoEndTimer();
        
        document.getElementById("callIdHolder").style.display = "none";
      } catch (error) {
        log(`âŒ Error accepting call: ${error.message}`);
        updateStatus("âŒ Failed to accept call", "error");
      }
    }

    function rejectCall() {
      if (!currentCallId) return alert("No call to reject!");
      socket.emit("call:rejected", { callId: currentCallId });
      log("âŒ Call rejected");
      resetCall();
    }

    function cancelCall() {
      if (!currentCallId) return alert("No call to cancel!");
      socket.emit("call:cancelled", { callId: currentCallId });
      log("ğŸ›‘ Call cancelled");
      resetCall();
    }

    function endCall() {
      if (!currentCallId) return alert("No active call to end!");
      socket.emit("call:ended", { callId: currentCallId });
      log("ğŸ“´ Call ended by user");
      resetCall();
    }

    function resetCall() {
      currentCallId = null;
      targetUserId = null;
      isCallInitiator = false;
      
      document.getElementById("callIdHolder").style.display = "none";

      if (peerConnection) {
        peerConnection.close();
        peerConnection = null;
        log("ğŸ”— Peer connection closed");
      }

      if (callTimer) {
        clearTimeout(callTimer);
        callTimer = null;
      }

      // Keep local stream running for next call
      // Clear remote video only
      document.getElementById("remoteVideo").srcObject = null;
      
      updateRemoteStatus("Waiting for connection");
      updateStatus("Ready for new call", "");
      
      log("ğŸ”„ Call reset completed (camera kept active)");
    }

    function startAutoEndTimer() {
      const minutes = parseInt(document.getElementById("callDuration").value) || 2;
      const ms = minutes * 60 * 1000;

      callTimer = setTimeout(() => {
        log(`â° Auto-ending call after ${minutes} minutes`);
        endCall();
      }, ms);

      log(`â° Auto-end timer set for ${minutes} minutes`);
    }

    // Initialize
    log("ğŸš€ WebRTC Video Call Interface Ready");
    updateStatus("Ready - Test camera first, then connect", "");
    updatePermissionStatus("ğŸ¥ Click 'Test Camera' to grant permissions first", false);
  </script>
</body>
</html>