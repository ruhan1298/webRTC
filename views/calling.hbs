<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Multi-User Call Room</title>
    <style>
    body {
      margin: 0;
      font-family: 'Inter', sans-serif;
      background: #0e0e0e;
      color: #f1f1f1;
      display: flex;
      flex-direction: column;
      height: 100vh;
    }

    header {
      background: #1f1f1f;
      padding: 16px 40px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-weight: 600;
      font-size: 1.2rem;
      border-bottom: 1px solid #333;
      position: sticky;
      top: 0;
      z-index: 999;
    }

    #callTimer {
      font-family: 'Courier New', Courier, monospace;
      font-size: 1rem;
      background: #333;
      padding: 8px 14px;
      border-radius: 8px;
    }

    main {
      flex: 1;
      display: grid;
      grid-template-columns: 2fr 1fr;
      gap: 20px;
      padding: 20px 30px;
      background: #141414;
      overflow-y: auto;
    }

    .videos {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 16px;
      padding: 10px;
    }

    video {
      width: 100%;
      border-radius: 12px;
      background: black;
      object-fit: cover;
      aspect-ratio: 4 / 3;
      border: 3px solid #3a8ee6;
      box-shadow: 0 0 10px rgba(0,0,0,0.6);
    }

    .rightPanel {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 10px;
    }

    .controls button,
    .controls select,
    .controls input[type="color"],
    .controls input[type="range"] {
      background: #3a8ee6;
      border: none;
      color: white;
      font-size: 0.95rem;
      padding: 10px 14px;
      border-radius: 8px;
      cursor: pointer;
      transition: 0.3s ease;
      min-width: 90px;
    }

    .controls button:hover,
    .controls select:hover {
      background: #2c6fc2;
    }

    #clearBtn {
      background: #e63946;
    }
    #clearBtn:hover {
      background: #c92e3b;
    }

    canvas#whiteboard {
      border: 2px dashed #555;
      border-radius: 10px;
      background: #1a1a1a;
      height: 300px;
      width: 100%;
      box-shadow: inset 0 0 10px rgba(0,0,0,0.4);
    }

    #chatSection {
      background: #1e1e1e;
      border-radius: 10px;
      padding: 15px;
      display: flex;
      flex-direction: column;
      height: 250px;
    }

    #chatBox {
      flex: 1;
      overflow-y: auto;
      padding-right: 10px;
      font-size: 0.9rem;
      color: #ddd;
      border-bottom: 1px solid #444;
      margin-bottom: 10px;
    }

    #chatBox div {
      margin-bottom: 8px;
      word-wrap: break-word;
    }

    #chatInput {
      padding: 10px;
      border-radius: 8px;
      border: none;
      font-size: 1rem;
      background: #2c2c2c;
      color: white;
    }

    #chatInput:focus {
      background: #3a8ee6;
    }
  #colorPicker {
  width: 70px;
  height: 70px;
  padding: 0;
  border: none;
  background: none;
  cursor: pointer;
}

    @media (max-width: 800px) {
      main {
        grid-template-columns: 1fr;
        padding: 15px;
      }

      canvas#whiteboard {
        height: 250px;
      }

      header {
        flex-direction: column;
        gap: 8px;
        text-align: center;
      }

    }
  </style>
</head>
<body>
  <header>
    <div>Room ID: <strong id="roomId">#12345</strong></div>
    <div id="callTimer">00:00</div>
  </header>

  <main>
    <div class="videos" id="videosContainer">
      <video id="localVideo" autoplay muted playsinline></video>
    </div>

    <div class="rightPanel">
      <div class="controls">
        <button onclick="toggleAudio()">Mute</button>
        <button onclick="toggleVideo()">Video</button>
        <button onclick="startScreenShare()">Share</button>
        <button onclick="endCall()">End</button>
      </div>

      <div class="controls">
        <select id="toolSelect">
          <option value="pencil">Pencil</option>
          <option value="brush">Brush</option>
          <option value="eraser">Eraser</option>
          <option value="line">Line</option>
          <option value="rectangle">Rectangle</option>
          <option value="circle">Circle</option>
          <option value="text">Text</option>
        </select>
        <input type="color" id="colorPicker" value="#ffffff"  />
        <input type="range" id="brushSize" min="1" max="40" value="5" />
        <button id="clearBtn">Clear</button>
      </div>

      <canvas id="whiteboard" width="800" height="600"></canvas>

      <section id="chatSection">
        <div id="chatBox"></div>
        <input id="chatInput" placeholder="Type and press Enter..." onkeydown="if(event.key==='Enter') sendMessage(this.value)" />
      </section>
    </div>
  </main>

  <script src="/socket.io/socket.io.js"></script>
 <script>
  const socket = io();

  // Get room from URL or default
  const urlParams = new URLSearchParams(window.location.search);
  const room = urlParams.get('room') || 'default-room';
  document.getElementById('roomId').innerText = room;

  const localVideo = document.getElementById('localVideo');
  const videosContainer = document.querySelector('.videos');
  const chatBox = document.getElementById('chatBox');

  let localStream;
  const peers = {}; // socketId -> RTCPeerConnection
  let startTime;

  const config = {
    iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
  };

  // Get local media and join room
  (async () => {
    try {
      localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
      localVideo.srcObject = localStream;
      socket.emit('join', room);
    } catch (e) {
      alert('Could not access camera and microphone: ' + e.message);
    }
  })();

  socket.on('all-users', users => {
    users.forEach(userId => {
      createPeerConnection(userId, true);
    });
    startTimer();
  });

  socket.on('user-joined', userId => {
    createPeerConnection(userId, false);
  });

  socket.on('offer', async ({ from, offer }) => {
    const pc = createPeerConnection(from, false);
    await pc.setRemoteDescription(new RTCSessionDescription(offer));
    const answer = await pc.createAnswer();
    await pc.setLocalDescription(answer);
    socket.emit('answer', { to: from, answer: pc.localDescription });
  });

  socket.on('answer', async ({ from, answer }) => {
    const pc = peers[from];
    if (!pc) return;
    await pc.setRemoteDescription(new RTCSessionDescription(answer));
  });

  socket.on('ice-candidate', ({ from, candidate }) => {
    const pc = peers[from];
    if (!pc) return;
    pc.addIceCandidate(new RTCIceCandidate(candidate));
  });

  socket.on('user-left', userId => {
    if (peers[userId]) {
      peers[userId].close();
      delete peers[userId];
    }
    const videoEl = document.getElementById('remoteVideo-' + userId);
    if (videoEl) {
      videoEl.srcObject = null;
      videoEl.parentNode.removeChild(videoEl);
    }
  });

  // Chat message received
  socket.on('chat-message', ({ from, msg }) => {
    const you = from === socket.id ? 'You' : `User ${from.substring(0, 6)}`;
    chatBox.innerHTML += `<div><b>${you}:</b> ${msg}</div>`;
    chatBox.scrollTop = chatBox.scrollHeight;
  });

  // Create peer connection and set up handlers
  function createPeerConnection(userId, isInitiator) {
    if (peers[userId]) return peers[userId];

    const pc = new RTCPeerConnection(config);
    peers[userId] = pc;

    // Add local tracks to peer connection
    localStream.getTracks().forEach(track => pc.addTrack(track, localStream));

    // Create video element for this remote user
    let remoteVideo = document.getElementById('remoteVideo-' + userId);
    if (!remoteVideo) {
      remoteVideo = document.createElement('video');
      remoteVideo.id = 'remoteVideo-' + userId;
      remoteVideo.autoplay = true;
      remoteVideo.playsInline = true;
      remoteVideo.style.width = '300px';
      remoteVideo.style.border = '3px solid #3a8ee6';
      remoteVideo.style.borderRadius = '12px';
      remoteVideo.style.boxShadow = '0 0 12px rgba(0,0,0,0.8)';
      videosContainer.appendChild(remoteVideo);
    }

    const remoteStream = new MediaStream();
    remoteVideo.srcObject = remoteStream;

    pc.ontrack = event => {
      event.streams[0].getTracks().forEach(track => remoteStream.addTrack(track));
    };

    pc.onicecandidate = event => {
      if (event.candidate) {
        socket.emit('ice-candidate', { to: userId, candidate: event.candidate });
      }
    };

    if (isInitiator) {
      pc.createOffer().then(offer => {
        pc.setLocalDescription(offer).then(() => {
          socket.emit('offer', { to: userId, offer: pc.localDescription });
        });
      });
    }

    return pc;
  }

  // Chat message send
  function sendMessage(msg) {
    if (!msg.trim()) return;
    socket.emit('chat-message', { room, msg });
    chatBox.innerHTML += `<div style="text-align:right; color:#7fbf7f;"><b>You:</b> ${msg}</div>`;
    chatBox.scrollTop = chatBox.scrollHeight;
    document.getElementById('chatInput').value = '';
  }

  // Audio toggle
  function toggleAudio() {
    if (!localStream) return;
    const audioTrack = localStream.getAudioTracks()[0];
    audioTrack.enabled = !audioTrack.enabled;
  }

  // Video toggle
  function toggleVideo() {
    if (!localStream) return;
    const videoTrack = localStream.getVideoTracks()[0];
    videoTrack.enabled = !videoTrack.enabled;
  }

  // Screen share
  async function startScreenShare() {
    try {
      const screenStream = await navigator.mediaDevices.getDisplayMedia({ video: true });
      const screenTrack = screenStream.getVideoTracks()[0];

      // Replace track on each peer connection
      for (const userId in peers) {
        const sender = peers[userId].getSenders().find(s => s.track.kind === 'video');
        if (sender) sender.replaceTrack(screenTrack);
      }

      // Update local video preview
      localVideo.srcObject = screenStream;

      screenTrack.onended = () => {
        // Restore original camera video track
        for (const userId in peers) {
          const sender = peers[userId].getSenders().find(s => s.track.kind === 'video');
          if (sender) sender.replaceTrack(localStream.getVideoTracks()[0]);
        }
        localVideo.srcObject = localStream;
      };
    } catch (e) {
      alert('Screen share failed or cancelled.');
    }
  }

  // Call timer
  function startTimer() {
    startTime = Date.now();
    setInterval(() => {
      const diff = Date.now() - startTime;
      const mins = Math.floor(diff / 60000);
      const secs = Math.floor((diff % 60000) / 1000);
      document.getElementById('callTimer').innerText = `${mins}:${secs.toString().padStart(2, '0')}`;
    }, 1000);
  }

  // End call
  function endCall() {
    for (const userId in peers) {
      peers[userId].close();
      delete peers[userId];
      const videoEl = document.getElementById('remoteVideo-' + userId);
      if (videoEl) {
        videoEl.srcObject = null;
        videoEl.parentNode.removeChild(videoEl);
      }
    }
    if (localStream) {
      localStream.getTracks().forEach(track => track.stop());
    }
    socket.emit('leave', room);
    window.location.reload(); // Or redirect somewhere
  }
    // Whiteboard drawing and tools
    document.addEventListener('DOMContentLoaded', () => {
      const canvas = document.getElementById('whiteboard');
      const ctx = canvas.getContext('2d');
      const clearBtn = document.getElementById('clearBtn');
      const statusEl = document.getElementById('status');
      const colorPicker = document.getElementById('colorPicker');
      const brushSizeInput = document.getElementById('brushSize');
      const toolSelect = document.getElementById('toolSelect');

      const roomId = room;

      let drawing = false;
      let startX = 0;
      let startY = 0;
      let currentTool = toolSelect.value;
      let currentColor = colorPicker.value;
      let brushSize = parseInt(brushSizeInput.value, 10);
      let eraserEnabled = false;
      let textInputActive = false;

      // Utility to get mouse position relative to canvas
      function getMousePos(evt) {
        const rect = canvas.getBoundingClientRect();
        return {
          x: evt.clientX - rect.left,
          y: evt.clientY - rect.top
        };
      }

      // Clear canvas
      clearBtn.addEventListener('click', () => {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        socket.emit('whiteboard-clear', roomId);
      });

      // Tool select
      toolSelect.addEventListener('change', e => {
        currentTool = e.target.value;
        eraserEnabled = (currentTool === 'eraser');
        statusEl.textContent = `Selected Tool: ${currentTool}`;
      });

      // Color picker
      colorPicker.addEventListener('change', e => {
        currentColor = e.target.value;
      });

      // Brush size
      brushSizeInput.addEventListener('input', e => {
        brushSize = parseInt(e.target.value, 10);
      });

      // Draw line helper
      function drawLine(x1, y1, x2, y2, color, size) {
        ctx.strokeStyle = color;
        ctx.lineWidth = size;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
      }

      // Draw rectangle helper
      function drawRect(x, y, w, h, color, size) {
        ctx.strokeStyle = color;
        ctx.lineWidth = size;
        ctx.strokeRect(x, y, w, h);
      }

      // Draw circle helper
      function drawCircle(x, y, radius, color, size) {
        ctx.strokeStyle = color;
        ctx.lineWidth = size;
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, 2 * Math.PI);
        ctx.stroke();
      }

      // Draw text helper
      function drawText(x, y, text, color, size) {
        ctx.fillStyle = color;
        ctx.font = `${size * 4}px sans-serif`;
        ctx.fillText(text, x, y);
      }

      let lastX = 0;
      let lastY = 0;

      // Mouse down
      canvas.addEventListener('mousedown', (e) => {
        if (textInputActive) return; // prevent drawing while text input active

        drawing = true;
        const pos = getMousePos(e);
        startX = pos.x;
        startY = pos.y;
        lastX = pos.x;
        lastY = pos.y;

        if (currentTool === 'text') {
          // Create a text input at clicked position
          createTextInput(pos.x, pos.y);
          drawing = false;
          return;
        }
      });

      // Mouse move
      canvas.addEventListener('mousemove', (e) => {
        if (!drawing) return;
        const pos = getMousePos(e);

        if (currentTool === 'pencil' || currentTool === 'brush' || currentTool === 'eraser') {
          const color = (currentTool === 'eraser') ? '#121212' : currentColor;
          const size = (currentTool === 'brush') ? brushSize * 2 : brushSize;
          drawLine(lastX, lastY, pos.x, pos.y, color, size);
          socket.emit('whiteboard-draw', {
            roomId,
            tool: currentTool,
            color,
            size,
            fromX: lastX,
            fromY: lastY,
            toX: pos.x,
            toY: pos.y
          });
          lastX = pos.x;
          lastY = pos.y;
        }
      });

      // Mouse up
      canvas.addEventListener('mouseup', (e) => {
        if (!drawing) return;
        drawing = false;
        const pos = getMousePos(e);

        // Shapes and line tools draw shape on mouse up
        if (['line', 'rectangle', 'circle'].includes(currentTool)) {
          let shapeData = null;
          switch (currentTool) {
            case 'line':
              drawLine(startX, startY, pos.x, pos.y, currentColor, brushSize);
              shapeData = { type: 'line', startX, startY, endX: pos.x, endY: pos.y, color: currentColor, size: brushSize };
              break;
            case 'rectangle':
              const width = pos.x - startX;
              const height = pos.y - startY;
              drawRect(startX, startY, width, height, currentColor, brushSize);
              shapeData = { type: 'rectangle', startX, startY, width, height, color: currentColor, size: brushSize };
              break;
            case 'circle':
              const radius = Math.sqrt(Math.pow(pos.x - startX, 2) + Math.pow(pos.y - startY, 2));
              drawCircle(startX, startY, radius, currentColor, brushSize);
              shapeData = { type: 'circle', centerX: startX, centerY: startY, radius, color: currentColor, size: brushSize };
              break;
          }
          if (shapeData) {
            socket.emit('whiteboard-shape', { roomId, shapeData });
          }
        }
      });

      // Mouse leave - stop drawing if mouse leaves canvas
      canvas.addEventListener('mouseleave', () => {
        drawing = false;
      });

      // Text input creation
      function createTextInput(x, y) {
        if (textInputActive) return;
        textInputActive = true;

        const input = document.createElement('input');
        input.type = 'text';
        input.style.position = 'absolute';
        input.style.left = (canvas.offsetLeft + x) + 'px';
        input.style.top = (canvas.offsetTop + y) + 'px';
        input.style.fontSize = (brushSize * 4) + 'px';
        input.style.color = currentColor;
        input.style.background = 'transparent';
        input.style.border = '1px solid ' + currentColor;
        input.style.outline = 'none';
        input.style.zIndex = 1000;
        input.style.padding = '2px 5px';
        input.style.width = '150px';

        document.body.appendChild(input);
        input.focus();

        input.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            const text = input.value.trim();
            if (text.length > 0) {
              drawText(x, y + brushSize * 4, text, currentColor, brushSize);
              socket.emit('whiteboard-text', { roomId, x, y: y + brushSize * 4, text, color: currentColor, size: brushSize });
            }
            document.body.removeChild(input);
            textInputActive = false;
          } else if (e.key === 'Escape') {
            document.body.removeChild(input);
            textInputActive = false;
          }
        });
      }

      // Socket listeners for whiteboard events
      socket.on('whiteboard-draw', data => {
        if (data.roomId !== roomId) return;
        drawLine(data.fromX, data.fromY, data.toX, data.toY, data.color, data.size);
      });

      socket.on('whiteboard-shape', data => {
        if (data.roomId !== roomId) return;
        const s = data.shapeData;
        switch (s.type) {
          case 'line':
            drawLine(s.startX, s.startY, s.endX, s.endY, s.color, s.size);
            break;
          case 'rectangle':
            drawRect(s.startX, s.startY, s.width, s.height, s.color, s.size);
            break;
          case 'circle':
            drawCircle(s.centerX, s.centerY, s.radius, s.color, s.size);
            break;
        }
      });

      socket.on('whiteboard-text', data => {
        if (data.roomId !== roomId) return;
        drawText(data.x, data.y, data.text, data.color, data.size);
      });

      socket.on('whiteboard-clear', rId => {
        if (rId !== roomId) return;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      });

    });

</script>

</body>
</html>
